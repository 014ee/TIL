# Methods

{% hint style="info" %}
Array 클래스에 정의된 메서드는 배열을 다룰 때 자주 사용된다. **배열 메서드 중 일부는 원래 배열을 그대로 둔 채 새 배열을 반환하며, 나머지 메서드는 원래 배열을 수정하고 그 참조를 반환**하므로 이 둘의 차이를 알고 있어야 한다.
{% endhint %}

## 🐇 배열 이터레이터 메서드

{% hint style="info" %}
이 절에서 설명하는 메서드는 배열 요소를 순서대로 함수에 전달하는 방식으로 동작혀며, 배열 요소를 순회, 변환, 필터, 체크, 축소할 수 있다. 모두 **첫번째 인자로 함수를 받으며, 각 배열 오소에 대해 함수를 한번씩 호출**한다. 성긴 배열이라면 존재하지 않는 요소에 대해서는 함수를 호출하지 않는다. 대부분의 경우 이 함수는 배열 요소의 값, 인덱스, 배열 자체 세가지 인자를 받으며, 첫번째 인자만 사요하고 두번째와 세번째는 무시할 때도 많다.

선택적으로 두번째 인자를 지정할 수 있는데, **두번째 인자를 지정했다면 첫번째 인자인 함수는 자신이 그 두번째 인자의 메서드인 것처럼 호출된다. 즉, 두번째 인자가 함수의 this**가 된다. 때문에 첫번째 인자의 함수는 다른 곳에서 따로 정의 후 사용하는 방식보다는 인라인으로 작성하는 경우가 대부분이고, 화살표 함수 문법과 특히 잘 어울린다.
{% endhint %}

> **forEach() => 반환 X (기존 배열만 수정)**
>
> forEach()는 함수의 인자에 배열 요소의 값, 인덱스, 배열 자체를 인자로 전달해 해당 함수를 호출한다. 배열 요소의 값에만 관심이 있다면 인자 하나만 받는 함수를 작성하고 나머지 값은 무시해도 된다. forEach()에서 모든 요소를 함수에 전달하기 전에 break 등으로 반복을 멈추는 방법은 없다.

```javascript
const data = [1, 2, 3];
data.forEach(function(v, i , a) {a[i] = v + 1}); // [2, 3, 4]: 기존 배열을 수정한다.
```

> **map() => 새 배열 반환**
>
> map() 메서드는 forEach()에 전달하는 함수와 같은 방법으로 호출하지만, 그 함수가 반환한 값으로 이루어진 배열을 반환한다는 차이가 있다. 즉, map()은 새 배열을 반환하며 기존 배열은 수정하지 않는다. 또한 성긴 배열이라면 존재하지 않는 요소에 대해서는 함수를 호출하지 않지만, 반환된 배열 역시 같은 위치에 갭이 있으며 길이 또한 같다.

```javascript
const a = [1, 2, 3];
const b = a.map(num => num+1);
b // [2, 3, 4]: 새로운 배열을 반환한다.
a // [1, 2, 3]: 기존 배열은 그대로다.
```

> **filter() => 새 배열 반환**
>
> filter() 메서드는 인자로 전달한 판별 함수의 반환값이 true이거나 true로 변환될 수 있는 값이면 기존 배열의 해당 요소를 새로운 배열에 포함시켜 반환한다. 성긴 배열에서 존재하지 않는 값은 건너뛰며, 반환하는 배열은 항상 빽빽한 배열다.

```javascript
const a = [1, 2, 비어있음 , 3];
const b = a.filter(num => num > 2); 
b // [3]
a // [1, 2, 비어있, 3]
```

> **find()와 findIndex() => 일하는 첫번째 요소 반환**
>
> 판별 함수에서 true 같은 값을 반환하는 요소를 찾아 배열을 순회한다는 점은 filter() 와 같으나 이들 메서드는 기준을 만족하는 첫번째 요소를 찾는 즉시 순회를 멈추고 find()는 그 요소를, findIndex()는 그 요소의 인덱스를 반환한다. 만족하는 요소를 찾지 못하면 find()는 undefined를 findIndex()는 -1을 반환한다.

```javascript
const a = [1, 2, 3, 4];
a.find(num => num%2 === 0);   // 2: 2의 배수 중 첫번째 요소 반환
a.findIndex(num => num < 5);  // 0: 5보다 작은 수 중 첫번째 요소의 인덱스 반
```

> **every()와 some() => true 또는 false 반환**
>
> 배열 요소에 판별 함수를 적용하고 결과에 따라 true 또는 false 를 반환한다.\
> every() 메서드는 판별 함수가 배열의 모든 요소에 대해 true를 반환할 대만 true를 반환하며, some()메서드는 배열 요소 중 판별 함수가 true를 반환하는 것이 하나라도 있으면 true를 반환한다.\
> every()와 some()은 자신이 어떤 값을 반환할지 확실해지는 순간 순회를 멈추므로 some()은 모든 요소가 false 일 때, every()는 모든 요소가 true 일 때만 배열 전체를 순회한다. 또한 수학적 관습에 따라 빈 배열을 호출했을 수학 every()는 true를 반환하고, some()은 false를 반환한다.

```javascript
const a = [1, 2, 3, 4];
a.every(num => typeof num === 'number'); // true: 모든 요소가 조건을 충족한다.
a.every(num => num > 3);                 // false: 모든 요소가 조건을 충족하지 않는다.
a.some(num => num > 3);                  // true: 4는 3보다 크다.
a.some(isNaN);                           // false: 숫자가 아닌 것은 하나도 없다.
```

> **reduce()와 reduceRight() => 누적 값 반환**
>
> reduce()와 reduceRight()는 첫번째 인자로 제공하는 함수를 사용해 배열 요소를 하나의 값으로 만들어 주며, 이는 함수형 프로그래밍에서 흔히 쓰이는 방식이다. 이 첫번째 인자로 쓰이는 함수는 어떤 방식으로든 값 두개를 받아서 하나를 반환한다. 함수를 처음 호출할 때에는 그동안 행한 작업이 없으니 선택사항으로 두번째 인자로 초깃값을 넣어 초기값을 세팅해줄 수 있다. 그렇게 되면 함수를 처음 호출할 때는 두번째 인자의 초기값을 사용하고, 두번째 이후에는 이전 호출에서 반환한 값을 사용한다.

```javascript
const a = [1, 2, 3];
a.reduce((acc, val) => acc + val, 0); // 6: 0 + 1 + 2 + 3
a.reduce((acc, val) => (acc > val) ? x : val) // 3: 초기값이 없으면 첫번째, 두번째 요소가 인자로 들어간다.
```

```javascript
const a = [{name: 'LEE', age: 30}]
a.reduce((a, b) => {...a, ...b}, {}); // 이런식으로 객체를 합치는 용도로도 사용할 수 있다.
```

> reduceRight()는 reduce()와 마찬가지지만 오른쪽에서 왼쪽으로 진행한다는 점이 다르며, 축소 동작의 결합성이 오른쪽에서 왼쪽일 경우 이 메서드가 유용할 수 있다.

```javascript
const a = [1, 2, 3, 4];
a.reduceRight((acc, val) => acc/val);  // 0.6666666666666666: 4/3/2/1
a.reduce((acc, val) => acc/val);       // 0.041666666666666664: 1/2/3/4
```

{% hint style="info" %}
빈 배열에 초깃값 없이 reduce()를 호출하면 TypeError가 일어나며, 값이 하나만 있는 배열에서도 초깃값을 생략하고 호출하거나, 빈 배열에 초깃값을 넘기면서 호출하는 등 reduce()에 값을 하나만 넘기면 그 값을 그대로 반환하며 함수는 호출하지 않는다.

또한 reduce()와 reduceRight() 모두 축소 함수에서 this로 사용될 인자는 받지 않으므로 축소 함수를 다른 객체의 메서드로 호해야 한다면 Function.bind() 메서드를 이용해야 한다.
{% endhint %}

## 🐇 배열 평탄화 (ES2019)

> **flat() => 중첩되지 않은 새 배열 반환**
>
> flat() 메서드는 기존 배열과 같은 요소로 이루어진 평탄한(중첩되지 않은) 새 배열을 반환한다. 인자 없이 호출하면 한 단계만 평탄화 되며,  평탄화 레벨을 늘리려면 인자로 숫자를 전달해야 한다.

```javascript
[1, 2, [3, 4]].flat();    // [1, 2, 3, 4] 
[1, 2, [3, [4]]].flat();  // [1, 2, 3, [4]]
[1, 2, [3, [4]]].flat(2);  // [1, 2, 3, 4]
```

> **flatMap() => map() 돌면서 flat() 실행**
>
> flatMap() 메서드는 map()과 똑같이 동작하지만 반환하는 배열이 flat()에 전달한 것 처럼 자동으로 평탄화된다는 점이 다르다. 즉, a.flatMap(f)는 a.map(f).flat()과 동일하지만 더 효율적이다.

```javascript
const pharases = ['hello world', 'hello earth'];
const words = pharases.flatMap(phrase => phrase.split(' '));
words // ['hello', 'world', 'hello', 'earth']
```

## 🐇 배열 병합

> **concat() => 새 배열 반환**
>
> 기존의 배열 요소 뒤에 concat()의 인자를 포함하는 새 배열을 만들어 반환한다. 인자에 배열이 들어있으면 비열이 아니라 그 요소를 추가하지만, 배열의 배열을 재귀적으로 평탄화하지는 않는다.&#x20;

```javascript
const a = [];            // []
a.concat(1, 2);          // [1, 2]
a.concat([3], [4, 5]);   // [1, 2, 3, 4, 5]: 배열은 평탄화 된다.
a.concat(6, [7, [8]]);   // [1, 2, 3, 4, 5, 6, 7, 8]: 중첩 배열은 평탄화 되지 않는다.
```

{% hint style="info" %}
cancat()은 원래 배열의 사본을 만들어 반환하는데 이는 비용이 드는 작업이다. 때문에 a = a.concat(b) 같은 코드를 자주 쓰고 있다면 push()나 slice()를 대신할 수는 없는지 생각해보자.
{% endhint %}

## 🐇 스택과 큐

> **push()와 pop() => 기존 배열 수**
>
> push()와 pop() 는 배열을 스택처럼 다루는 메서드이다. push()는 배열의 끝에 하나 이상의 새 요소를 추가한 후 해당 배열을 반환하며, concat()과 달리 배열 인자를 평탄화하지 않는다. 따라서 분해 연산자를 사용해 직접 평탄화해야 다. pop() 메서드는 반대로 배열의 마지막 요소를 꺼내서 배열의 길이를 줄인 후 해당 배열을 반환한다. 두 메서드는 모두 기존 배열을 수정 후 해당 배열을 반환한다.

```javascript
let stack = [];            // []
stack.push(1, 2);          // [1, 2]
stack.pop();               // [1]
stack.push(...[2, 3, 4]);  // [1, 2, 3, 4]
```

> **unshift()와 shift() => 기존 배열 수정**
>
> unshift()는 배열의 앞 부분에 요소를 추가한 후 기존 배열을 뒤로 밀고 해당 배열을 반환한다. shift()는 배열의 첫번째 요소를 꺼내 반환하며, 기본 배열은 앞으로 당긴다. unshift()와 shift()을 사용해서 배열을 스택처럼 사용할 수 있긴 하지만, 명령할 때마다 기존 배열 요소를 앞뒤로 미는 작업이 수반되어야 하므로 push()나 pop()에 비해 비휼적이다.

```javascript
const queue = [];          // []
queue.push(0, 1, 2);       // [0, 1, 2]
q.shift();                 // [1, 2]
q.push(3);                 // [1, 2, 3]              
```

## 🐇 하위 배열

> **slice() => 잘라진 요소들로 이루어진 새 배열 반환**
>
> slice() 메서드는 지정된 배열의 하위 배열을 반환한다. 두개의 인자는 각각 반환될 슬라이스의 시작과 끝 위치를 나타내며, 첫번째 인자로 지정된 요소에서 시작해 두번째 인자로 지정된 요소 바로 앞까지 포함 슬라이스가 반환된다. 인자를 하나만 사용한다면 해당 위치부터 배열의 마지막 요소까지 반환되며, 인자에 음수를 사용한다면 그 값에 배열 길이를 더한 값을 적용한다. (-1은 배열의 마지막 요소이고, -2는 마지막에서 바로 앞 요소이다.)

```javascript
let a = [-1, 0, 1, 2, 3, 4, 5, 6, 7];
a.slice(2);     // [1, 2, 3, 4, 5, 6, 7]
a.slice(0, 5);  // [1, 2, 3, 4, 5]
a.slice(1, -2)  // [2, 3]
```

> **splice() => 제거된 요소로 이루어진 배열 반환**
>
> splice()는 기존 배열의 요소를 제거하거나 추가하는 범용 메서드로, 반환값은 제거된 요소로 이루어진 배열이며 제거된 것이 없다면 빈 배열을 반환한다. splice() 메서드의 첫번째 인자는 제거 또는 삽입을 시작할 위치이고, 두번째 인자에는 제거할 배열 요소의 갯수를 지정할 수 있으며 두번째 인자를 생략하면 첫번째 인자에 지정한 시작 위치부터 배열의 마지막 요소까지 모두 제거된다. 그 뒤에는 개수 제한 없이 인자를 쓸 수 있으며 이들은 첫번째 인자에서 지정한 위치에서 부터 배열에 삽입된다.&#x20;

```javascript
let a = [1, 2, 3, 4, 5, 6, 7, 8];
a.splice(4);             // [5, 6, 7, 8], a: [1, 2, 3, 4]ja
a.splice(3, 1);          // [4], a: [1, 2, 3, 4]
a.splice(1, 2, [2, 3]);  // [2, 3], a: [1, [2, 3], 4]
```

{% hint style="info" %}
splice()는 요소 제거 및 추가시 원래 배열을 수정하며 제거나 삽입이 이루어진 위치 다음에 오는 요소들은 앞이나 뒤로 밀어 배열을 빽빽하 유지한다. 또한 concat()과 달리 배열을 있는 그대로 삽입하며 평탄화하지 않는다.
{% endhint %}

> **fill() => 기존 배열의 값을 수정해서 반환**
>
> 배열의 요소 또는 슬라이스를 지정된 값으로 변경 후 원래 배열을 수정해 반환한다. 첫번째 인자는 배열 요소로 사용할 값이며, 선택사항인 두번째 인자는 시작 인덱스이다. 또 다른 선택사항인 세번째 인자는 마지막 인덱스이며 지정시 해당 인덱스의 바로 앞까지 작업하며 slice()와 마찬가지로 음수를 전달하면그 값에 배열 길이를 더해 적용한다.

```javascript
let a = new Array(5);    // [비어있음 x 5]
a.fill(0);               // [0, 0, 0, 0, 0]
a.fill(9, 1);            // [0, 9, 9, 9, 9]
a.fill(8, 2, -1);        // [0, 9, 8, 8, 9]
```

> **copyWithin()**
>
> copyWithin()은 배열의 슬라이스를 복사해 새 위치에 붙여 넣는 메서드로 기존 비열을 수정해 반환하지만 길이는 바뀌지 않는다. 첫번째 인자는 요소가 복사될 위치의 인덱스이며, 두번째 인자는 복사할 슬라이스의 시작 인덱스이고 두번째 인자를 생략하면 0을 사용한다. 세번째 인자는 복사할 슬라이스의 끝을 지정하는 인덱스이며 지정한 인덱스의 앞까지를 복사한다. (생략하면 배열 길이를 사용) 또한 다른 메서드와 마찬가지로 음수를 사용하면 그 값을 배열 길이에 더해 적용한다.&#x20;

```javascript
let a = [1, 2, 3, 4, 5];
// 1번째 인덱스에 0번째 요소부터 배열 마지막 요소까지 복사 덮어쓴다.
a.copyWithin(1);          // [1, 1, 2, 3, 4]
// 2번째 인덱스에 3번째 요소부터 5번째 요소 앞까지 복사해 덮어쓴다.
a.copyWithin(2, 3, 5);    // [1, 1, 3, 4, 4]
// 0번째 인덱스에 배열 끝에서 2번째 요소부터 배열 마지막 요소까지 복사해서 덮어쓴다.
a.copyWithin(0, -2);      // [4, 4, 3, 4, 4] 
```

{% hint style="info" %}
copyWithin()은 고성능을 목표로 설계된 메서드이며 형식화 배열에 특히 유용하다. 이 메서드는 C 표준 라이브러리의 memmove() 함수를 모델로 만들어졌다. 원본과 대상 영역에 겹치는 부분이 있더라도 복사는 정확히 동작한다.
{% endhint %}

## 🐇 배열 검색 메서드

> **indexOf(), lastIndexOf()**
>
> &#x20;지정된 값을 배열에서 찾아 그 첫번째 요소의 인덱스를 반환하며, 찾지 못하면 -1을 반환한다. indexOf()는 배열의 앞에서부터 검색을 시작하고, lastIndexOf()는 배열의 뒤에서부터 역순으로 검색한다. 인자와 배열 요소를 비교할 때는 === 연산자를 사용하므로 배열에 기본값이 아니라 객체가 들어있다면 이들 메서드는 두 참조가 정확히 같은 객체를 참조하는지 확인한다. 선택사항인 두번째 인자에는 검색을 시작할 배열 인덱스를 입력할 수 있다. (음수 사용시 배열 길이를 더한 값 적용) 문자열의 indexOf()와 lastIndexOf() 메서드도 마찬가지로 동작하지만, 두번째 인자가 음수이면 0으로 취급한다는 점이 다르다.&#x20;

```javascript
// 배열 array에서 값 target을 모두 찾아 인덱스의 배열로 반환하는 함수
function findAll(array, target) {
  let result = [], len = array.length, pos = 0;
  while(pos < len) {
    pos = array.indexOf(target, pos);
    if(pos === -1) break;
    result.push(pos);
    pos += 1;
  } 
  return result;
}
findAll([1, 2, 3, 4, 3, 2, 1], 3);  // [2, 4]
```

> **includes() (ES2016)**
>
> includes()는 인자를 하나 받고 배열에 그 값이 포함되어 있으면 true, 아니면 false를 반환하는데 이는 Set 객체의 포함 관계 테스트를 배열에 도입한 것이라고 생각해볼 수도 있다. indexOf()와 비슷한 기능을 하는 것 처럼 보이나 중요한 차이가 있는데, indexOf()가 === 연산자를 사용해 NaN을 자기 자신을 포함해 어떤 값과도 다르다고 판단한다면, includes()는 NaN이 자기 자신과는 일치한다고 판단하는 조금 다른 알고리즘을 사용한다.

```javascript
const a = [1, true, 3, NaN];
a.include(NaN);  // true
a.indexOf(NaN);  // -1: false
```

## 🐇 배열 정렬 메서드

> **sort()**
>
> &#x20;sort()는 배열 요소를 정렬해주는데, 인자 없이 호출하면 알파벳순(필요하다면 임시로 문자열로 변환)으로 정렬한다. (이때 배열에 정의되지 않은 요소가 있다면 배열 마지막으로 밀린다.) 알파벳이 아닌 다른 순서로 정렬하고 싶다면 인자로 반드시 비교 함수를 전달해야 한다.\
> 비교 함수는 어떤 인자가 앞에 있어야 하는지 결정하는데, 첫번째 인자가 두번째보다 앞에 있어야 한다면 비교 함수가 0보다 작은 숫자를 반환해야하며, 반대로 첫번째 인자가 두번째보다 뒤에 있어야 한다면 0보다 큰 숫자를 반환해야 한다. 그리고 두 값이 동등하다면 함수가 0을 반환해야 한다.&#x20;

```javascript
let nums = [true, 'tree', 4, 111, '22', undefined];
nums.sort();                 // [111, '22', 4, 'tree', true, undefined]: 알파벳순
nums.sort((a, b) => a - b);  // [true, 4, '22', 111, 'tree', undefined]
nums.sort((a, b) => b - a);  // [111, '22', 4, true, 'tree', undefined]
```

> **reverse()**
>
> 배열 요소의 순서를 거꾸로 바꾸어 반환하는데, 새 배열을 만들지 않고 기존 배열의 요소 순서를 뒤집는다.

```javascript
let a = [1, 2, 3, 4];
a.reverse();  // [4, 3, 2, 1]
```

## 🐇 배열을 문자열로 변환

{% hint style="info" %}
Array 클래스에는 배열을 문자열로 변환하는 메서드가 세 가지 있는데 일반적으로 로그나 에러 메세지를 만들 때 이 메서드를 사용한다. 나중에 재사용할 목적을 ㅗ뱅려 콘텐츠를 텍스트 형태로 바꾸는 것이라면 JSON.stringify()를 사용해야 한다.
{% endhint %}

> **join() => 새 문자열 반환**
>
> 배열 요소 전체를 문자열로 변환한 다음 이들을 병합한 결과를 반환한다. 인자에 결과 문자열에서 각 요소를 구분하는 문자열을 선택 사항으로 지정할 수도 있으며, 구분자를 지정하지 않으면 콤마를 사용한다.&#x20;

```javascript
let a = [1, 2, 3];
a.join();    // '1,2,3'
a.join('');  // '123'
a.join(' '); // '1 2 3'
let b = new Array(10);
b.join('-'); // '---------'
```

> **toSting()**
>
> toString()은 join() 메서드를 인자 없이 호출하는 것과 동일하다.

```javascript
[1, 2, 3].toString();       // '1,2,3'
['a', 'b', 'c'].toString(); // 'a,b,c'
[1, [2, 'c']].toString();   // '1,2,c'
```

> **toLocaleString()**
>
> toLocaleString()은 toString()을 해당 지역에 맞게 바꾼 버전이다.

```javascript
let a = [1, 'a', new Date()];
a.toLocaleString('kr');  // '1,a,2022. 6. 17. 오후 9:14:32'
a.toLocaleString('en');  // '1,a,6/17/2022, 9:14:32 PM'
```

## 🐇 정적 배열 함수

{% hint style="info" %}
위 배열 메서드 외에도 Array 클래스에는 Array 생성자를 사용해 호출할 수 있는 정적 함수가 세가지 있다. Arrays 페이지의 배열 생성에서 설명한 Array.of()와 Array.from()은 새 배열을 만드는 팩토리 메서드이고 Array.isArray()는 값이 배열인지 확인해주는 메서드이다.
{% endhint %}

```javascript
Array.isArray([]);  // true
Array.isArray({});  // false
```
