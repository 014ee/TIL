# Objects

## 🐇 객체란?

{% hint style="info" %}
객체는 **프로퍼티의 순서 없는 집합**이며 각 프로퍼티에는 이름과 값이 있다. 프로퍼티 이름은 보통 문자열(간혹 심벌)이므로 문자열에 값을 연결한다고 볼 수 있다. 이런 동작을 다른 언어에서 '해시', '해시 테이블', '딕셔너리', '연관배열' 같은 이름으로 부른다. 객체 내 프로퍼티와 메서드를 통틀어 '멤버'라고 부른다.
{% endhint %}

> **이름 (key)**
>
> 빈 문자열과 심벌을 포함해 어떤 문자열든 쓸 수 있지만, 같은 이름의 프로퍼티는 존재할 수 없다.

> **값 (value)**
>
> 자바스크립트 표현식(값)이면 무엇이든 가능하며, 터나 세터 또는 둘 다가 될 수 있다.

{% hint style="info" %}
자바스크립트 객체는 동적이기 때문에 프로퍼티를 추가하거나 삭제할 수 있지만, 이름과 값 외에도 아래와 같은 세 가지 프로퍼티 속성을 가지고 있어 정적인 객체를 흉내 낼 수도 있고 정적 타입을 사용하는 언어의 구조 역시 사용할 수 있다.

자바스크립트 내장 객체의 프로퍼티 중 상당수는 읽기 전용이거나 열거 불가이거나 변경 불가이며, 직접 만드는 객체의 프로퍼티는 기본적으로 쓰기 가능, 열거 가능, 변경 가능이다.
{% endhint %}

> **쓰기 가능 (writable)**
>
> 쓰기 가능 속성은 프로퍼티에 값을 설정할 수 있는지 없는지를 나타낸다.

> **열거 가능 (enumerable)**
>
> 열거 가능 속성은 for/in 루프에 프로퍼티 이름을 반환할지 안할지를 나타낸다.

> **변경 가능 (configurable)**
>
> 변경 가능 속성은 프로퍼티를 삭제할 수 있는지 없는지, 속성을 바꿀 수 있는지 없는지를 나타낸다.

## 🐇 프로토타입 상속

{% hint style="info" %}
자바스크립트 객체는 단순히 문자열과 값을 연결한 자신만의 프로퍼티 즉 **자체 프로퍼티를 가지는 것 외에도 다른 객체로부터 '프로토타입'이라는 프로퍼티를 상속**받는다. 객체의 메서드는 일반적으로 상속된 프로퍼티이며, 객체에서 직접 정의한 프로퍼티와 프로토타입 객체에서 상속받은 프로퍼티를 구별하는 것이 중요할 때도 있으므로 '프로토타입 상속'은 자바스크립트의 중요한 기능이다.&#x20;
{% endhint %}

> **프로토타입 체인**
>
> 기억할 것은 거의 모든 객체에 프로토타입이 있지만, prototype 프로퍼티가 있는 객체는 비교적 적다는 것이다. **prototype 프로퍼티를 갖는 객체가 다른 객체의 프로토타입을 정의**한다.
>
> **Object.prototype은 프로토타입이 없는 드문 객체** 중 하나로, 이 객체는 어떤 프로토타입도 상속받지 않는다. 다른 프로토타입 객체는 일반적인 객체로, Object.prototype로부터 상속받는 프로토타입이 있다. 가령 Date.prototype은 Object.prototype에서 프로퍼티를 상속받으므로 new Date()로 생성한 Date 객체는 Date.prototype과 Object.prototype 양쪽에서 프로퍼티를 상속받는다. 이렇게 이어지는 프로토타입 객체 사이의 연결을 프로토타입 체인이라고 한다.

## 🐇 객체 생성

> **객체 리터럴**
>
> 객체를 생성하는 가장 쉬운 방법으로 이름: 값 쌍을 콤마로 구분해 중괄호로 감싼 형태이다.\
> 객체 리터럴은 평가할 때마다 새 객체가 만들어자며, 각 프로퍼티의 값 역시 리터럴을 평가할 때마다 평가된다. 따라서 객체 리터럴 자체가 바뀌지 않더라도 반복적으로 호출되는 함수나 루프 바디 안에 있다면 새 객체를 여러개 만들 수 있으며, 이 객체들의 프로퍼티 값 역시 매번 달라질 수 있다.

```
const obj = {x: point.x, y: point.y+1,} // Object.prototype으로부터 프로토타입 상속
/* 
* 객체 리터럴의 마지막 프로퍼티에 콤마를 사용하면
* 나중에 객체 리터럴에 프로퍼티를 추가할 때 문법 에러를 초래할 가능성이 줄어든다.
*/
```

> **new 연산자**
>
> new는 새 객체를 생성하고 초기화하는 연산자로, new 키워드 뒤에는 반드시 함수 호출이 있어야 한다.\
> 이런 형태로 사용되는 함수를 생성자 함수라고 부르며, new 키워드로 새로 생성된 객체를 초기화하는 목적으로 사용된다. 자바스크립트 내장 타입에도 생성자가 있으며, 직접 생성자 함수를 만들 수도 있다.

```
const obj = new Object();  // Object.prototype으로부터 프로토타입 상속
const array = new Array(); // Array.prototype으로부터 프로토타입 상속
const date = new Date();   // Date.prototype으로부터 프로토타입 상
```

> **Object.create()**
>
> Object.create()는 첫번째 인자를 프로토타입 삼아 새 객체를 생성한다. 인자로 null을 전달해 프로토타입이 없는 객체를 생성할 수도 있지만, 이렇게 생성된 객체는 아무것도 상속받지 않으며, toString()같은 기본 메서드 조차 사용할 수 없다. {}나 new Object()처럼 일반적인 빈 객체를 만들고 싶을 때는 Object.prototype을 전달한다.&#x20;
>
> 임의의 프로토타입을 사용해 새 객체를 만들 수 있는 것은 강력한 기능이며, 서드 파티 라이브러리에서 부주의하게 객체의 프로퍼티 값을 변경하지 못하게 하기 위 목적으로 사용할 수 있다.

```
const nothing = Object.create(null);         // 아무것도 상속받지 않는 빈 객
const obj = Object.create(Object.prototype);
const obj = Object.create({x: 1, y: 2,});
```

## 🐇 확장된 객체 리터럴 문법

{% hint style="info" %}
자바스크립트 최근 버전에서는 객체 리터럴 문법을 여러 가지 방법으로 확장했다.
{% endhint %}

> **단축 프로퍼티 (ES6)**
>
> 객체의 프로퍼티 이름과 할당할 값이 담긴 변수의 이름이 같다면 콜론을 생략할 수 있다.

```
const a = 1, b = 2;
const obj = {a, b};
```

> **계산된 프로퍼티 이름 (ES6)**
>
> 프로퍼티 이름이 변수에 저장되어 있거나 함수의 반환값일 때, 객체 리터럴 안에서 추가할 수 있다. 대괄호 안에는 임의의 자바스크립트 표현식이 들어가며, 표현식을 평가한 값이 프로퍼티 이름으로 사용된다.

```
const NAME = 'name';
function computePropertyName() {return 'age'}
const person = {
  [NAME]: 'Lee',
  [computePropertyName()]: 30,
}
```

> **프로퍼티 이름인 심벌 (ES6)**
>
> 계산된 프로퍼티 문법을 통해 프로퍼티 이름에 문자열이나 심벌을 쓸 수 있게 되었다. 심벌은 다른 어떤 심벌과도 같지 않으므로 **고유한 프로퍼티 이름을 만들 때 안성맞춤**이다. 예를 들어 직접 제어할 수 없는 서드 파티 코드에서 가져온 객체에 프로퍼티를 추가하고 싶지만, 추가한 프로퍼티가 이미 존재하는 프로포티와 충돌하지 않는다고 확신할 수 없을 때 심벌을 통해 안전하게 추가할 수 있다. 하지만 서드 파티 코드에서 Object.getOwnPropertySymbos()를 사용해 추가한 심벌을 확인한다면 수정이나 삭제가 가능해지므로 심벌의 목적은 보안이 아니라 자바스크립트 객체가 사용할 수 있는 **안전한 확장 메커니즘을 정의**한다는 것을 숙지하고 있어야 한다.

```
const extension = Symbol('myExtension');
const obj = {
  myExtension: '기존 프로퍼티'
  [extension]: {a: 1}  // obj의 다른 로퍼티와 충돌하지 않는다.
}
obj  // {extension: "기존 프로퍼티", Symbol(extension): {a: 1}}
```

> **분해 연산자 (ES2018)**
>
> 객체 리터럴 안에서 **분해 연산자 ... 를 사용해 기존 객체의 자체 프로퍼티를 새 객체에 복사**할 수 있다. 같은 이름의 프로퍼티를 갖는다면 마지막에 오는 값이 덮어쓰게 되며, 자체 프로퍼티만 분해할 뿐 상속받은 프로퍼티는 분해하지 않는다.

```
const apple = {apple: '사과', price: 1000}
const banana = {banana: '바나나', price: 2000}
const fruits = {...apple, ...banana}
fruits  // {apple: '사과', banana: '바나나', price: 2000}
```

{% hint style="info" %}
객체에 프로퍼티가 n개 있으면 이 프로퍼티를 다른 객체로 분해하는 작업은 O(n) 작업이다. 따라서 ...를 루프나 재귀 함수에 넣어 데이터를 큰 객체 하나에 누산한다면 n이 커질 수록 O(p²) 알고리즘을 쓰게 된다.
{% endhint %}

> **단축 메서드 (ES6)**
>
> ES6이후 메서드를 정의할 때 function 키워드와 콜론을 생략할 수 있으며, 이를 통해 데이터와 메서드를 명확하게 구분할 수 있게 되었다.  프로퍼티 이름에는 객체 리터럴 안에 쓸 수 있다면 문자열, 계산된 프로퍼티, 심벌 등 무엇이든 쓸 수 있다. (for/of 루프에서 사용할 수 있도록 이터러블로 만드려며 반드시 심벌 이름을 사용해 메서드를 정의해야 한다.)

```
const square = {
  side: 10,
  area() {return this.side * this.side;}
}
```

> **접근자 프로퍼티 게터와 세터 (ES5)**
>
> &#x20;프로그램이 접자 프로퍼티의 값을 검색하면 자바스크립트는 인자 없이 게터 메서드를 호출하며, 이 메서드의 반환 값이 값이 된다. 프로그램에서 접근자 프로퍼티의 값을 설정하려 하면 자바스크립트는 세터 메서드를 호출하고 할당 표현식의 오른쪽 값을 인자로 전달하며, 세터 메서드의 반환 값은 무시된다. 접근자 프로퍼티는 데이터 프로퍼티와 마찬가지로 상속되므로 다른 객체의 프로토타입으로 사용할 수 있다.

{% hint style="info" %}
프로퍼티에 게터와 세터 메서드가 모두 있으면 해당 프로퍼티는 읽기와 쓰기가 모두 가능한 프로퍼티이다.
{% endhint %}

{% hint style="info" %}
게터 메서드 하나만 있다면 읽기 전용 프로퍼티이다.
{% endhint %}

{% hint style="info" %}
세터 메서드 하나만 있다면 쓰기 전용 프로퍼티(데이터 프로퍼티에서는 불가능)이며, 값을 읽으려고 하면 항상 undefined로 평가된다.
{% endhint %}

```
const obj = {
  max: 10,                  // 일반적인 데이터 프로퍼티
  min: 1,                   // 일반적인 데이터 프로퍼티
  get sum() {               // getter 접근자 프로퍼티
    return (this.max + this.min) / 2;
  },      
  set changeNum(max, min) { // setter 접근자 프로퍼티
    this.max = max;
    this.min = min
  }  
}
```

> 접근자 프로퍼티를 사용하는 이유 중에는 프로퍼티에 쓸 때 유효성 검사를 하고, 읽을 때마다 다른 값을 반환하게 하는 것도 있다.

```
const serialNum = {
  // 프로퍼티에 있는 _는 내부에서만 사용한다는 일종의 컨벤션이다.
  _num: 0;
  
  // 현재 값을 증가시켜 반환한다.
  get next() {return this._num++;}
  
  // _num에 새 값을 할당하려면 현재 값보다 커야한다.
  set next(num) {
    if(num > this._num) this._num = num;
    esle throw new Error('serial number can only be set to a larger value');
  }
}
serialNum.next = 10;  // 시리얼 번호 시작을 정한다.
serialNum.next        // 10
serialNum.next        // 11
```

## 🐇 객체 확장

{% hint style="info" %}
객체의 프로퍼티를 다른 객체에 복사하는 것은 흔한 일이며, 이런 기능을 쉽게 사용할 수 있도록 ES6에서 Object.assgin()을 도입하였다.
{% endhint %}

> **Object.keys()**
>
> ES6 전에는 key를 순회하며 하나씩 복사하는 방법을 사용했다.

```
let target = {}, source = {a: 1, b: 2};
for(let key of source) {
  target[key] = source[key]
}
target // {a: 1, b: 1}
```

> **Object.assign()**
>
> 첫번째 인자는 수정해서 반환할 대상 객체이며, 두번째 또는 그 이후의 인자는 소스 객체이다. 각 소스 객체를 인자에 입력한 순서대로 순회하면 열거 가능한 자체 프로퍼티(심벌 포함)를 대상 객체에 복사한다. 나중에 입력한 소스 객체가 이전에 입력한 소스 객체와 동일한 프로퍼티를 가지고 있다면 덮어 쓰게 되며, 소스 객체에 게터 메서드가 있다면 복사 도중 호출되긴 하지만 메서드 자체를 복사하지는 않는다.

```
let obj = {a: 0}
Object.assign(obj, {a: 1}, {b: 2});
obj  // {a: 1, b: 2}: 이름이 동일한 기존 프로퍼티가 기존 값을 덮어다.
```

{% hint style="info" %}
값을 전부 덮어 쓰는 것이 아니라 소스 객체에 기본 값을 정의해 두고 대상 객체에 그런 이름이 존재하지 않는다면 복사해서 쓰는 등의 목적으로 사용하려면 아래와 같이 사용해야 한다.
{% endhint %}

```
let obj = {a: 0}
obj = Object.assign({}, {a: 1}, {b: 2}, x);
obj  // {a: 0, b: 2}: 기본 값을 마지막에 덮어써 주었다.
```

```
let obj = {a: 0}
obj = {...{a: 1}, ...{b: 2}, ...obj}  // 분해 연산자를 이용해 값을 덮어 쓸 수도 있다.
```

```
// 또는 직접 구현할 수도 있다.

functin merge(target, ...sources) {
  for(let source of sources) {             // 복사할 소스 객체 배열 순회
    for(let key of Object.keys(source)) {  // 소스 객체 내 key 값 순회
      if(!(key in target)) {               // 대상 객체에 해당 key가 없는 경우에만 
        target[key] = source[key];         // 새로운 프로퍼티로 할당
      }
    }
  }
}
```

## 🐇 객체 직렬화

{% hint style="info" %}
객체 직렬화는 객체를 문자열로 변환하는 작업을 말하며 **JSON.stringify()**를 사용하여 수행할 수 있다. 이 문자열은 **JSON.parse()**를 사용하여 다시 객체로 되돌릴 수 있다.&#x20;

여기서 사용하는 JSON 문법은 자바스크립트 문법의 부분 집합이며, 자바스크립트 값 전체를 표현하지는 못한다. 객체, 배열, 문자열, 유한한 숫자, true, false, null 은 직렬화와 복원 모두 가능한 반면 함수, RegExp, Error 객체, undefined의 경우 직렬화와 복원 모두 불가능하다.
{% endhint %}

> **JSON.stringify()**
>
> JSON.stringify()는 열거 가능한 자체 프로퍼티만 직렬화한다. 프로퍼티 값을 직렬화할 수 없다면 해당 프로퍼티는 결과 문자열에서 생략된다. 또한 NaN, Infinity, -Infinity는 null로 직렬화다.&#x20;

> **JSON.parse()**
>
> Date 객체는 ISO 형식 문자열로 직렬화 되지만 복원시에는 문자열을 그대로 둘 뿐 Date 객체로 복원되지 않는다.&#x20;
