# Properties

## 🐇 프로퍼티 접근 표현식

{% hint style="info" %}
프로퍼티에 접근할 때는 점(.)이나 대활호(\[]) 연산자를 사용한다. 점 연산자를 사용하면 오른쪽은 반드시 프로퍼티 이름인 단순한 '식별자'' 여야 하며, 대괄호를 사용한다면 그 안에 있는 값은 문자열 또는 문자열이나 심벌로 변환될 수 있는 값로 평가되는 '표현식'이어야 한다.
{% endhint %}

> **점 연산자**
>
> 점 연산자를 사용해 객체 프로퍼티에 접근할 때 프로퍼티 이름은 식별자로 표현된다. 식별자는 **반드시 문자 그대로 입력**해야하며, 식별자는 데이터 타입이 아니로 프로그램에서 조작할 수 없다.

> **대괄호 연산자**
>
> 객체 프로퍼티에 접근할 때는 프로퍼티 이름을 문자열로 표현한다. 문자열은 **데이터 타입이므로 프로그램이 실행되는 동안 새로 생성할 수도 있고 조작할 수도 있다.** 대괄호 연산자처럼 문자열을 인덱스로 사용하는 배열을 연관 배열, '해시', '맵', '딕셔너리' 라고 한다.

```
obj.property;       // C나 자바에서 정적 필드에 접근하는 것과 유사
obj['property'];    // 문자열을 인덱스로 사용하는 배열에 접근하는 것과 유사
```

## 🐇 프로퍼티 검색

{% hint style="info" %}
객체 obj의 프로퍼티 x 를 가져온다고 했을 때, obj에 x라는 자체 프로퍼티가 없다면, obj의 프로토타입 객체에서 x를 검색한다. 프로토타입 객체에도 자체 프로퍼티 x는 없지만 프로토타입이 있다면 또 다시 obj의 프로토타입의 프로토타입에서 x를 검색한다. 이 과정은 x 프로퍼티를 찾거나, 프로토타입이 null인 객체에 도달할 때까지 계속된다.
{% endhint %}

## 🐇 프로퍼티 설정

{% hint style="info" %}
obj 객체에 x 프로퍼티 값을 할당하면 먼저 프로토타입 체인을 검색해 할당이 허용되는지 확인한다. obj에 읽기 전용인 x 프로퍼티가 존재하거나 상속받고 있다면 할당은 허용되지 않는다. 할당이 가능할 경우 obj에 이미 자체 x 프로퍼티가 있다면 할당은 기존의 값을 바꾸고, 없으면 x 프로퍼티를 새로 만들고 거기에 값을 할당한다. 만약 obj에 상속받은 프로퍼티 x가 있었다면, 상속된 프로퍼티는 새로 생성된 자체 프로퍼티에 가려진다. (새로 만들어진 자체 프로퍼티에 값이 가려질 뿐, 프로토타입 체인에 존재하는 객체는 수정되지 않는다.)
{% endhint %}

> **세터 메서드 상속시 발생하 예외**
>
> 원래 객체에 새로운 x 프로퍼티를 할당하는 규칙에는 한가지 예외가 있는데, obj가 x 프로퍼티를 상속받고, 그 프로퍼티가 세터 메서드가 있는 접근자 프로퍼티라면 obj에 새로운 x 프로퍼티를 만드는 대신 세터 메서드를 호출한다. 하지만 세터 메서트는 객체 obj에 호출되는 것이지 해당 프로퍼티를 정의한 프로토타입 객체에 호출되는 것이 아니므로, 세터 메서드가 프로퍼티를 변경하더라고 obj에 변화가 있을 뿐 프로토타입 체인은 변하지 않는다.&#x20;

## 🐇 프로퍼티 접근 에러

{% hint style="info" %}
프로퍼티 접근 표현식이 항상 값을 반환하거나 설정하는 것은 아니다.\
자바스크립트 객체에서 존재하지 않는 프로퍼티를 검색하는 것은 에러가 아니며 자체 프로퍼티나 상속받은 프로퍼티 모두에서 찾고자 하는 프로퍼티를 찾지 못하면 프로퍼티 undefined로 평가된다. null과 undefined에는 프로퍼티가 없으므로 이런 값에서 프로퍼티를 검색하려 하는 것은 에러이다.
{% endhint %}

```
const obj = {}
obj.x          // undefined
obj.x.length   // TypeError
```

> **조건문을 이용한 접근 에러 대응**
>
> 따라서 obj.x.length같은 표현식을 만들 때 obj 와 obj.x가 실제로 정의돼었는지 확신할 수 없다면 주의해야 하며, 다음과 같은 방법들 대응할 수 있다.

```
obj && obj.x && obj.x.length;  // && 연산자의 단축평가 
obj?.x?.length;                // 조건부 프로퍼티 접근 연산
```

> **cf. 할당 에러**
>
> * 할당하고자 하는 프로퍼티가 자체 프로퍼티에 읽기 전용으로 있는 경우
> * 할당하고자 하는 프로퍼티가 상속받은 프로퍼티에 읽기 전용으로 있는 경우
> * 해당 객체의 확장 가능 속성이 false이고, 프로퍼티를 할당하기 위한 세터 메서드가 없는 경우

## 🐇 프로퍼티 삭제

{% hint style="info" %}
delete 연산자를 이용해 객체에서 프로퍼티를 삭제할 수 있다. delete 연산자는 자체 프로퍼티만 삭제할 뿐 상속받은 프로퍼티는 삭제하지 않는다. delete 표현식은 삭제에 성공했을 때, 또는 존재하지 않는 프로퍼티 삭제를 시도하는 등 효과가 없었을 때 true로 평가된다.
{% endhint %}

```
delete obj.x;   // true: 이제 obj에는 x 프로퍼티가 없다.
```

> **삭제 불가한 경우**
>
> delete는 변경 가능 속성이 false인 프로퍼티는 제거하지 않으며, 내장 객체의 일부 프로퍼티, 변수 선언이나 함수 전언으로 생성된 전역 객체의 프로퍼티는 변경 불가하다. 스트릭스 모드에서는 변경 불가인 프로퍼티를 삭제하려 하면 TypeError가 발생하며, 일반 모드에서는 에러가 일어나지 않고 false로 평가된다.

```
delete Object.prototype // TypeError (일반 모드에서는 false)
function func() {}      // 전역에서 선언한 함수도 삭제할 수 없다.
delete globalTils.func  // TypeError (일반 모드에서는 false)
```

## 🐇 프로퍼티 테스트

{% hint style="info" %}
in 연산자, hasOwnProperty(), propertyIsEnumerable() 메서드를 사용하거나 그냥 프로퍼티를 검색하여 주어진 이름을 가진 프로퍼티가 객체에 존재하는지 확인할 수 있다.
{% endhint %}

> **직접 검색**
>
> 직접 프로퍼티를 검색하고 !==를 사용해 undefined가 아님을 확이나는 경우도 있다.

```
const obj = {a: undefined};
obj.a !== undefined;         // false: 프로퍼티가 존재하지만 정의되지 않았다.
obj.toString !== undefined;  // true
```

> **in 연산자**
>
> in 연산자는 왼쪽에 프로퍼티 이름, 오른쪽에 객체를 예상하며, 객체에 이름을 가진 자체 프로퍼티나 상속 프로퍼가 있다면 true를 반환한다. in 연산자는 존재하지 않는 프로퍼티와 존재하지만 값이 undefined인 프로퍼티를 구분할 수 있다.

```
'a' in obj;         // true: 값이 undefined라도 프로퍼티는 정의되었다.(직접 검색과 차)
'toString' in obj;  // true
```

> **hasOwnProperty()**
>
> 객체에 주어진 이름을 가진 자체 프로퍼티가 있는지 테스트하며, 상속된 프로퍼티는 false를 반환한다.

```
obj.hasOwnProperty('a');        // true: 자체 프로퍼
obj.hasOwnProperty('toString'); // fale: 자체 프로퍼티가 아님
```

> **propertyIsEnumerable()**
>
> hasOwnProperty()를 더 제한한 버전으로, 지정된 프로퍼티가 자체 프로퍼티이며, 열거 가능 속성이 true일 대만 true를 반환한다. (일부 내장 프로퍼티는 열거 불가이다.)

```
obj.propertyIsEnumerable('a');                  // true: 열거 가능 프로퍼티
obj.hasOwnProperty('toString');                 // fale: 자체 프로퍼티가 아
obj.prototype.propertiIsEnumerable('toString'); // false: 열거 불가능
```

## 🐇 프로퍼티 열거

{% hint style="info" %}
**for/in 루프**

지정된 객체의 상속 여부를 구분하지 않고 열거 가능 프로퍼티마다 그 이름을 루프 변수에 할당하면서 루프 바디를 실행한다. (내장 메서드는 열거 불가이지만, 직접 추가한 프로퍼티는 기본적으로 열거 가능이다.) 아래와 같이 명시적으로 체크하여 상속받은 프로퍼티는 열거되지 않도록 할 수 있다.&#x20;
{% endhint %}

```
for(let item in obj) {
  if(!obj.hasOwnProperty(item)) continue;       // 상속받은 프로퍼티는 건너뛴다.   
  if(typeof obj[item] === 'function') continue; // 메서드는 건너뛴다.
}
```

{% hint style="info" %}
**for/of 루프**&#x20;

객체의 프로퍼티 이름을 배열에 저장해서 for/of 루프를 사용하는 것이 더 쉬울 때가 많다. 프로퍼티 이름을 배열로 저장할 수 있는 함수는 네가지 이다.
{% endhint %}

> **Object.keys()**
>
> &#x20;열거 가능한 프로퍼티 이름을 배열로 반환한다. 열거 불가 프로퍼티, 상속된 프로퍼티, 이름이 심벌인 프로퍼티는 내보내지 않는다.
>
> ****
>
> **Object.getOwnPropertyNames()**
>
> Object.keys()와 비슷하지만 이름이 문자열이기만 하면 열거 불가인 자체 프로퍼티 이름도 배열로 반환한다.
>
>
>
> **Object.getOwnPropertySymbols()**
>
> 열거 가능 여부를 지지 않고 이름이 심벌인 자체 프로퍼티를 배열로 반환한다.
>
>
>
> **Reflect.ownKeys()**
>
> 열거 가능 여부를 따지지 않고, 문자열인지 심벌인지도 구분하지 않고 자체 프로퍼티 이름은 전부 배열로 반환한다.

{% hint style="info" %}
**프로퍼티 열거 순서**

객체 자체 프로퍼티를 열거하는 순서는 ES6에서 공식적으로 정의되었다. Object.keys(), Object.getOwnPropertyNames(),Object.getOwnPropertySymbols(), Relect.ownKey(), Json.stringify() 등 관련 메서드는 아래 순서에 따라 프로퍼티를 열거한다.
{% endhint %}

1. 이름이 음이 아닌 정수인 문자열 프로퍼티가 첫번째로 나열되며 작은수에서 큰 순으로 열거된다.
2. 음수나 부동 소수점 숫자처럼 보이는 프로퍼티를 포함해 이름이 문자열인 프로퍼티를 객체에 추가된 순서대로 열거한다.
3. 마지막으로, 이름이 심벌인 프로퍼티를 객체에 추가된 순서대로 열거한다.

{% hint style="info" %}
for/in 루프의 열거 순서는 열거 함수만큼 정확하게 정의되어 있지는 않지만 대부분 실행 환경에서 비슷한 순서로 열거되고, 프로토타입 체인을 따라 올라가면서 이미 열거된 프로퍼티를 제외하고 동일한 행위를 수행해 나간다.
{% endhint %}
