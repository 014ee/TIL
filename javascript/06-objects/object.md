# Objects

## 🐇 객체란?

{% hint style="info" %}
객체는 **프로퍼티의 순서 없는 집합**이며 각 프로퍼티에는 이름과 값이 있다. 프로퍼티 이름은 보통 문자열(간혹 심벌)이므로 문자열에 값을 연결한다고 볼 수 있다. 이런 동작을 다른 언어에서 '해시', '해시 테이블', '딕셔너리', '연관배열' 같은 이름으로 부른다. 객체 내 프로퍼티와 메서드를 통틀어 '멤버'라고 부른다.
{% endhint %}

> **이름 (key)**
>
> 빈 문자열과 심벌을 포함해 어떤 문자열든 쓸 수 있지만, 같은 이름의 프로퍼티는 존재할 수 없다.

> **값 (value)**
>
> 자바스크립트 표현식(값)이면 무엇이든 가능하며, 터나 세터 또는 둘 다가 될 수 있다.

{% hint style="info" %}
자바스크립트 객체는 동적이기 때문에 프로퍼티를 추가하거나 삭제할 수 있지만, 이름과 값 외에도 아래와 같은 세 가지 프로퍼티 속성을 가지고 있어 정적인 객체를 흉내 낼 수도 있고 정적 타입을 사용하는 언어의 구조 역시 사용할 수 있다.

자바스크립트 내장 객체의 프로퍼티 중 상당수는 읽기 전용이거나 열거 불가이거나 변경 불가이며, 직접 만드는 객체의 프로퍼티는 기본적으로 쓰기 가능, 열거 가능, 변경 가능이다.
{% endhint %}

> **쓰기 가능 (writable)**
>
> 쓰기 가능 속성은 프로퍼티에 값을 설정할 수 있는지 없는지를 나타낸다.

> **열거 가능 (enumerable)**
>
> 열거 가능 속성은 for/in 루프에 프로퍼티 이름을 반환할지 안할지를 나타낸다.

> **변경 가능 (configurable)**
>
> 변경 가능 속성은 프로퍼티를 삭제할 수 있는지 없는지, 속성을 바꿀 수 있는지 없는지를 나타낸다.

## 🐇 프로토타입 상속

{% hint style="info" %}
자바스크립트 객체는 단순히 문자열과 값을 연결한 자신만의 프로퍼티 즉 **자체 프로퍼티를 가지는 것 외에도 다른 객체로부터 '프로토타입'이라는 프로퍼티를 상속**받는다. 객체의 메서드는 일반적으로 상속된 프로퍼티이며, 객체에서 직접 정의한 프로퍼티와 프로토타입 객체에서 상속받은 프로퍼티를 구별하는 것이 중요할 때도 있으므로 '프로토타입 상속'은 자바스크립트의 중요한 기능이다.&#x20;
{% endhint %}

> **프로토타입 체인**
>
> 기억할 것은 거의 모든 객체에 프로토타입이 있지만, prototype 프로퍼티가 있는 객체는 비교적 적다는 것이다. **prototype 프로퍼티를 갖는 객체가 다른 객체의 프로토타입을 정의**한다.
>
> **Object.prototype은 프로토타입이 없는 드문 객체** 중 하나로, 이 객체는 어떤 프로토타입도 상속받지 않는다. 다른 프로토타입 객체는 일반적인 객체로, Object.prototype로부터 상속받는 프로토타입이 있다. 가령 Date.prototype은 Object.prototype에서 프로퍼티를 상속받으므로 new Date()로 생성한 Date 객체는 Date.prototype과 Object.prototype 양쪽에서 프로퍼티를 상속받는다. 이렇게 이어지는 프로토타입 객체 사이의 연결을 프로토타입 체인이라고 한다.

## 🐇 객체 생성

> **객체 리터럴**
>
> 객체를 생성하는 가장 쉬운 방법으로 이름: 값 쌍을 콤마로 구분해 중괄호로 감싼 형태이다.\
> 객체 리터럴은 평가할 때마다 새 객체가 만들어자며, 각 프로퍼티의 값 역시 리터럴을 평가할 때마다 평가된다. 따라서 객체 리터럴 자체가 바뀌지 않더라도 반복적으로 호출되는 함수나 루프 바디 안에 있다면 새 객체를 여러개 만들 수 있으며, 이 객체들의 프로퍼티 값 역시 매번 달라질 수 있다.

```
const obj = {x: point.x, y: point.y+1,} // Object.prototype으로부터 프로토타입 상속
/* 
* 객체 리터럴의 마지막 프로퍼티에 콤마를 사용하면
* 나중에 객체 리터럴에 프로퍼티를 추가할 때 문법 에러를 초래할 가능성이 줄어든다.
*/
```

> **new 연산자**
>
> new는 새 객체를 생성하고 초기화하는 연산자로, new 키워드 뒤에는 반드시 함수 호출이 있어야 한다.\
> 이런 형태로 사용되는 함수를 생성자 함수라고 부르며, new 키워드로 새로 생성된 객체를 초기화하는 목적으로 사용된다. 자바스크립트 내장 타입에도 생성자가 있으며, 직접 생성자 함수를 만들 수도 있다.

```
const obj = new Object();  // Object.prototype으로부터 프로토타입 상속
const array = new Array(); // Array.prototype으로부터 프로토타입 상속
const date = new Date();   // Date.prototype으로부터 프로토타입 상
```

> **Object.create()**
>
> Object.create()는 첫번째 인자를 프로토타입 삼아 새 객체를 생성한다. 인자로 null을 전달해 프로토타입이 없는 객체를 생성할 수도 있지만, 이렇게 생성된 객체는 아무것도 상속받지 않으며, toString()같은 기본 메서드 조차 사용할 수 없다. {}나 new Object()처럼 일반적인 빈 객체를 만들고 싶을 때는 Object.prototype을 전달한다.&#x20;
>
> 임의의 프로토타입을 사용해 새 객체를 만들 수 있는 것은 강력한 기능이며, 서드 파티 라이브러리에서 부주의하게 객체의 프로퍼티 값을 변경하지 못하게 하기 위 목적으로 사용할 수 있다.

```
const nothing = Object.create(null);         // 아무것도 상속받지 않는 빈 객
const obj = Object.create(Object.prototype);
const obj = Object.create({x: 1, y: 2,});
```

## 🐇 객체 확장

{% hint style="info" %}
객체의 프로퍼티를 다른 객체에 복사하는 것은 흔한 일이며, 이런 기능을 쉽게 사용할 수 있도록 ES6에서 Object.assgin()을 도입하였다.
{% endhint %}

> **Object.keys()**
>
> ES6 전에는 key를 순회하며 하나씩 복사하는 방법을 사용했다.

```
let target = {}, source = {a: 1, b: 2};
for(let key of source) {
  target[key] = source[key]
}
target // {a: 1, b: 1}
```

> **Object.assign()**
>
> 첫번째 인자는 수정해서 반환할 대상 객체이며, 두번째 또는 그 이후의 인자는 소스 객체이다. 각 소스 객체를 인자에 입력한 순서대로 순회하면 열거 가능한 자체 프로퍼티(심벌 포함)를 대상 객체에 복사한다. 나중에 입력한 소스 객체가 이전에 입력한 소스 객체와 동일한 프로퍼티를 가지고 있다면 덮어 쓰게 되며, 소스 객체에 게터 메서드가 있다면 복사 도중 호출되긴 하지만 메서드 자체를 복사하지는 않는다.

```
let obj = {a: 0}
Object.assign(obj, {a: 1}, {b: 2});
obj  // {a: 1, b: 2}: 이름이 동일한 기존 프로퍼티가 기존 값을 덮어다.
```

{% hint style="info" %}
값을 전부 덮어 쓰는 것이 아니라 소스 객체에 기본 값을 정의해 두고 대상 객체에 그런 이름이 존재하지 않는다면 복사해서 쓰는 등의 목적으로 사용하려면 아래와 같이 사용해야 한다.
{% endhint %}

```
let obj = {a: 0}
obj = Object.assign({}, {a: 1}, {b: 2}, x);
obj  // {a: 0, b: 2}: 기본 값을 마지막에 덮어써 주었다.
```

```
let obj = {a: 0}
obj = {...{a: 1}, ...{b: 2}, ...obj}  // 분해 연산자를 이용해 값을 덮어 쓸 수도 있다.
```

```
// 또는 직접 구현할 수도 있다.

functin merge(target, ...sources) {
  for(let source of sources) {             // 복사할 소스 객체 배열 순회
    for(let key of Object.keys(source)) {  // 소스 객체 내 key 값 순회
      if(!(key in target)) {               // 대상 객체에 해당 key가 없는 경우에만 
        target[key] = source[key];         // 새로운 프로퍼티로 할당
      }
    }
  }
}
```

## 🐇 객체 직렬화

{% hint style="info" %}
객체 직렬화는 객체를 문자열로 변환하는 작업을 말하며 **JSON.stringify()**를 사용하여 수행할 수 있다. 이 문자열은 **JSON.parse()**를 사용하여 다시 객체로 되돌릴 수 있다.&#x20;

여기서 사용하는 JSON 문법은 자바스크립트 문법의 부분 집합이며, 자바스크립트 값 전체를 표현하지는 못한다. 객체, 배열, 문자열, 유한한 숫자, true, false, null 은 직렬화와 복원 모두 가능한 반면 함수, RegExp, Error 객체, undefined의 경우 직렬화와 복원 모두 불가능하다.
{% endhint %}

> **JSON.stringify()**
>
> JSON.stringify()는 열거 가능한 자체 프로퍼티만 직렬화한다. 프로퍼티 값을 직렬화할 수 없다면 해당 프로퍼티는 결과 문자열에서 생략된다. 또한 NaN, Infinity, -Infinity는 null로 직렬화다.&#x20;

> **JSON.parse()**
>
> Date 객체는 ISO 형식 문자열로 직렬화 되지만 복원시에는 문자열을 그대로 둘 뿐 Date 객체로 복원되지 않는다.&#x20;
