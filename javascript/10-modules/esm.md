# ESM

## ESM이란?

{% hint style="info" %}
&#x20;ES6에서 import와 export 키워드를 자바스크립트에 추가하면서 마침내 언어 코어에서 모듈을 지원하기 시작했다. ES6의 모듈은 노드 모듈과 같은 개념이다. 각 파일이 하나의 모듈이며 파일에서 정의한 상수, 변수, 함수, 클래스는 명시적으로 내보내지 않는 한 해당 모듈에서만 사용된다. 하지만 ES6 모듈의 문법은 노드 모듈과 내보내기/가져오기 문법에 차이가 있고 웹 브라우저에서 모듈을 정의하는 방법도 다르다.
{% endhint %}

## ESM과 스크립트의 차이

{% hint style="info" %}
&#x20;일반 스크립트에서는 최상위에서 선언한 변수, 함수, 클래스는 모두 모든 스크랩트가 공유하는 전역 컨텍스트에 들어간다. 반면 모듈에서는 각 파일에 비공개 컨텍스트가 있으며 import, export 문을 사용할 수 있다. 또한 ES6 모듈의 코드는 ES6 class 문에 있는 코드와 마찬가지로 자동으로 스트릭트 모드에 들어간다. ES6 모듈은 스트릭트 모드보다 좀 더 엄격한데, 스트릭트 모드에서 함수로 호출된 함수의 this가 undefined라면, 모듈에서는 최상위 코드에서도 this가 undefined이며, 이는 웹 브라우저와 노드의 스크립트에서 this가 전역 객체인 것과 다르다.
{% endhint %}

## 웹과 노드의 모듈

{% hint style="info" %}
IE를 제외한 모든 웹 브라우저에서 ES6를 정식으로 지원하기 시작하면서 네이티브로 지원하는 브라우저에서는 \<script type='module'>태그를 사용해 ES6 모듈을  HTML 페이지에 삽입할 수 있게 되었다. 노드가 자바스크립트의 모듈화를 도왔다고 볼 수 있지만, 그 때문에 완전히 호환되지 않는 두 가지 모듈 시스템을 지원해야하는 상황에 처했다. 노드 13은 ES6 모듈을 지원하지만, 아직은 노드 프로그램 대다수가 노드 모듈을 사용한다.
{% endhint %}

## ESM 내보내기

{% hint style="info" %}
&#x20;ES6 모듈에서 상수, 변수, 함수, 클래스를 내보낼 때 다음과 같이 선언 앞에 export 키워드를 추가한다. export 키워드는 자바스크립트 코드의 최상위 레벨에만 존재할 수 있다. 이는 ES6 모듈 시스템의 중요한 특징이며 이 때문에 정적 분석이 가능한 것이다. 모듈은 항상 같은 값을 내보내며 내보낸 심벌은 모듈을 실제로 실행하기 전에 평가할 수 있다.
{% endhint %}

```javascript
export cosnt PI = Math.PI;
export function sum(x, y) {return x + y;}
```

{% hint style="info" %}
기존과 같이 상수, 변수, 함수, 클래스를 정의하고, export 문을 하나만 써서 무엇을 내보낼지 정확히 선언하는 방법도 있다. 이는 객체 리터럴 처럼 보일 수 있으나 내보니기 문법으로 중괄호 안에 콤마로 구분된 식별자 리스트를 쓰도록 정했을 뿐이다.
{% endhint %}

```javascript
export {PI, sum};
```

{% hint style="info" %}
함수나 클래스 하나만 내보내는 모듈을 만드는 경우에는 보통 export 뒤에 default를 붙여서 사용한다. export를 사용하는 일반 내보내기 이름이 있는 선언에서만 사용할 수 있다면 export default를 사용하는 디폴트 내보내기는 익명 함수 표현식과 익명 클래스 표현식을 포함해 어떤 표현식이든 내보낼 수 있다. 대신 디폴트 내보내기는 한 파일에 하나만 쓸 수 있으며 값을 가져오는 모듈에서 이름을 지정해야 한다.
{% endhint %}

```javascript
export defualt class BitSet {
  // 클래스 바
}
```

## ESM 가져오기

{% hint style="info" %}
다른 모듈에서 내보낸 값을 import 키워드로 가져올 수 있다. 가져온 값이 할당된 식별자는 const 키워드를 사용한 것처럼 상수로 선언된다. 내보내기와 마찬가지로 가져오기 역시 모듈의 최상위 레벨에만 존재할 수 있다. 거의 대부분의 개발자가 모듈에 필요한 가져오기를 할 때 모듈 맨 위에 작성하는데, 함수 선언과 마찬가지로 가져오기는 모듈 맨 위로 끌어올려지므로 가져온 값은 모듈 어디에서든 사용할 수 있다. 모듈 지정자 문자열은 반드시 /로 시작하는 정대 경로, ./나 ../로 시작하는 상대 경로, 프로토콜과 호스트 이름을 포함한 완전한 URL 중 하나여야 하며, 웹팩 같은 코드 번들링 도구는 라이브러리 디텍터리를 지정할 수 있으므로 이런 제한을 지키지 않는다.
{% endhint %}

```javascript
import BitSet from './bitset.js';  // 디폴트 내보내기로 정의한 모
```

{% hint style="info" %}
&#x20;여러 값을 내보내는 모에서  가져올 때는  다음과 같다. default를 사용하지 않는 내보내기에서는 내보내는 값에 이름이 있고, 가져오는 모듈에서는 그 이름으로 값을 참조한다. 내보내는 모듈에서 이름 붙은 값의 개수는 제한이 없으며, 해당 모듈을 참조하는 import 문은 중괄호 안에 원하는 이름을 써서 원하는 값만 가져올 수 있다. 이는 분해 할당과 비슷하게 보이며 실제로 비슷하게 동작한다. 중괄호 안에 있는 식별자는 모두 가져오는 모듈의 맨 위로 끌어올려지며 상수처럼 동작한다.
{% endhint %}

```javascript
import {mean, stddev} from './stats.js'; // 원하는 값만 가져올 수 있다.
improt * as stats from './stats.js'; // default 제외 내보내기 값을 모두 가져올 수 있다.
```

{% hint style="info" %}
&#x20;import 문은 내보내기가 전혀 없는 모듈도 가져올 수 있다. 이런 모듈은 처음 가져올 때 실행되며, 이어지는 가져오기는 아무 일도 하지 않는다. 함수를 정의하는 모듈은 함수를 최소 하나는 내보내야 의미가 있다. 하지만 모듈이 어떤 코드를 실행한다면 특별한 이름 없이 가져오기만 해도 의미가 있을 수 있다. 예를 들어 웹 애플리케이션 분석 모듈에서 이벤트 핸들러를 등록하고 이벤트 핸들러에서 필요한 데이터를 필요한 시간에 서버에 전송한다고 하면 ,이 모듈은 독립적이며 아무 것도 내보낼 필요가 없지만 프로그램의 일부로 실행되려면  import 문으로 가져와야 한다.
{% endhint %}

```javascript
import './analytics.js';
```

## 이름 바꾸기

{% hint style="info" %}
&#x20;가져오기나 내보내기 시 기존 이름을 바꿔야 할 때 다음과 같이 할 수 있다.
{% endhint %}

```javascript
import {render as renderImage} from './imageutils.js';
import {render as renderUI} from './ui.js';
import {default as Histogram, mean, stddev} from './histogram-stats.js';
```

```javascript
export {
  layout as calculateLayout,
  render as renderLayout
}
```

## 다시 내보내기

{% hint style="info" %}
다른 모듈의 여러 값을 하나로 묶어서 단지 내보내기만 하고 싶은 경우 ES6 모듈에서 만든 특별한 문법인 '다시 내보내기' 문을 사용할 수 있다.&#x20;
{% endhint %}

```javascript
export {mean} from './stats/mean.js';
export {stddev} from './stats/stddev.js';
```

{% hint style="info" %}
&#x20;다시 내보내기 할 대 필요한 것만 선택하지 않고 모듈에서 사용하는 값 전체를 내보낼 때는 와일드 카드를 쓸 수 있으며 다시 내보내기 문법은 일반적인 import, export 문과 마찬가지로 as 키워드를 허용한다.
{% endhint %}

```javascript
export * from './stats/mean.js';
export * from './stats/stddev.js';

export {mean as default} from './stats/mean.js';
export {default as stddev} from './stats/stddev.js';
```

## 웹의 자바스크립트 모듈

{% hint style="info" %}
&#x20;ESM이 생긴 이후에도 여전히 웹팩 같은 도구를 사용하고 있다. 장단이 있긴 하지만 전체적으로 볼 때 코드 번들링을 하면 성능이 더 좋아진다. 나중에 네트워크 속도가 더 빨라지고 브라우저 제조사들이 ESM 구현을 계속 최적화하면 상황이 바뀔 수도 있다. 실무에서 여전히 번들링 도구를 사용하고 있더라도 최신 브라우저는 모두 자바스크립트 모듈을 네이티브로 지원하기 때문에 앞으로의 개발에는 필요 없어질 수 있다. 모듈은 반드시 비모듈 코드와 다르게 실행되어야 하므로 ES6 모듈이 발전하면서 HTML도 바뀌었는데, 웹 브라우저에서 import 지시자를 네이티브로 사용할 때는 반드시 \<script type="module"> 태그를 써서 모듈 코드임을 알려야 한다.&#x20;

ESM은 각 모듈이 가져오기의 정적 세트를 갖는다는 특징이 있다. 웹 브라우저는 하나의 모듈에서 시작해 그 모듈이 가져오는 모듈을 모두 불러오는 식으로 프로그램 전체를 불러온다.  \<script type="module"> 태그는 모듈 프로그램의 출발점이며 이 모듈이 가져오는 모듈은  \<script> 태그에 쓰지 않더라도 일반적인 자바스크립트 파일로 불러오며 스트릭트 모드에서 실행된다.  type="module" 속성을 지정한 스크립트는 defer 속성을 가진 스크립트와 마찬가지로 로드되고 실행된다. 즉, HTML 파서가 \<script> 태그를 만나는 즉시 코드를 불러오기 시작하며 코드 실행은 HTML 분석이 끝날 때 까지 지연된다. HTML 분석이 끝나면 모듈 스크립트와 그렇지 않은 스크립트를 HTML 문서 소스 순서대로 실행한다.&#x20;

일반적인 스크립트와 마찬가지로 async 속성으로 모듈의 실행 시점을 바꿀 수도 있다.

\<script type='module'> 태그를 지원하는 웹 브라우저는 반드시 \<script nomodeule> 태그 역시 지원해야 한다. 모듈을 인식하는 브라우저는 nomodule 속성이 있는 스크립트를 모두 무시하고 실행하지 않으며 모듈을 지원하지 않는 브라우저는 속성을 무시하고 스크립트를 실행한다. ESM을 지원하는 브라우저는 최신 자바스크립트 기능도 지원하므로 최신 자바스크립트 코드를 작성하고  \<script type='module'> 를 사용하면 이를 지원하는 브라우저에만 불러올 수 있다.&#x20;

일반적인 스크립트와 모듈 스크립트 사이(cross-origin)에는 교차 출처 로드에도 차이가 있다. 일반적인 \<script> 태그는 인터넷에 존재하는 어떤 서버에서든 자바스크립트 코드 파일을 불러오는 반면, \<script type='module'>는  HTML 문서와 같은 서버 또는 CORS 헤더에서 허용하는 서버에서만 모듈을 불러옴으로써 교차 출처에 따른 위험을 줄여준다. 다만 새 보안 제한에는 개발 과정에서 file: URL을 써서 ESM 모듈을 테스트 하기 어렵하는 부작용이 있다. 때문에 ESM 모듈을 사용할 때는 테스트에 사용할 정적 웹 서버를 준비해야 한다. 일부 프로그래머는 모듈 파일에 .mjs 확장자를 사용해 전통적인 .js 확장자를 쓰는 비모듈 자바스크립트와 구분하기도 한다. 웹 브라우저와 \<script> 태그 입장에서는 어떤 파일 확장자를 쓰든 상관 없지만 MIME 타입은 확장자가 상관 있으므로 .mjs 파일을 사용한다면 웹 서버에서 이들을  .js 파일과 같은 MIME 타입으로 전송하도록 설정해야 한다. 노드는 확장자를 각 파일이 사용하는 모듈 시스템에 대한 힌트로 간주하므로 ESM를 노드에서 사용하려면 .mjs 확장자를 도입하는 것이 유용하다. \

{% endhint %}



## import()의 동적 가져오기

{% hint style="info" %}
&#x20; ESM의 import, export 지시자는 완전히 정적이므로 자바스크립트 인터프리터를 비롯한 다른 도구에서 모듈 코드를 실제로 실행하지 않고 단순히 텍스트만 분석함으로써 모듈 사이의 관계를 확인할 수 있다. 정적으로 가져온 모듈에서는 모듈로 가져온 값이 모듈의 코드보다 먼저 준비된다. 웹에서는 코드를 파일 시스템에서 읽지 안고 네트워크를 통해 전송한다. 전송이 끝난 코드는 비교적 느린 CPU를 탑재한 모바일 장치에서 실행될 때가 많은데, 이런 환경에서 프로그램 전체를 불러와야만 실행을 시작하는 정적 모듈을 가져오는 것은 별로 좋지 않다.

웹 애플리케이션에서는 첫번째 페이지를 렌더링하는데 필요한 코드만 먼저 불러오는 일이 흔하다. 그리고 사용자가 콘텐츠 일부를 사용할 수 있게 된 상황에서 나머지 부분에 필요한 코드를 계속 가져올 수 있다. 웹 브라우저는 DOM API를 사용해 현재 HTML 문서에 새 \<script> 태그를 삽입할 수 있으므로 이런 방식을 취한 웹 애플리케이션이 많다.&#x20;

동적 로딩은 이미 오랫동안 사용됐지만 자바스크립트 언어 자체의 일부는 아니었는데, ES2020에서 import()를 도입하면서 ESM를 지원하는 브라우저는 모두 동적 가져오기도 지원할 수 있게 되었다. 모듈 지정자를 import()에 전달하면 import()는 지정된 모듈을 비동기로 불러오고 실행하는 프로세스인 프라이스 객체를 반환한다. 동적 가져오기가 완료되면 프라미스는 이행(fulfill)되며 정적 가져오기 문 형태로 import \* as를 사용한 것 같은 객체를 반환한다.

import()의 인자는 정적 import 지시자와 마찬가지로 모듈 지정자를 써야 한다. 하지만 import()에서는 문자열 리터럴뿐만 아니라 적절한 문자열 형태로 평가되는 표현식도 쓸 수 있다.&#x20;
{% endhint %}

```javascript
// 정적으로 가져오는 코드
import * as stats from './stats.js';

// 동적으로 가져오는 코드
import('./stats.js').then(stats => {
  let average = stats.mean(data);
})

// async 함수라면 await를 써서 단순화할 수 있다.
async analyzeData(data) {
  let stats = await import('./stats.js');
  return {
    average: stats.mean(data);
    stddev: stats.stddev(data);
  }
}
```

{% hint style="info" %}
마지막으로 동적 import()는 웹 브라우저 전용이 아니다. 웹팩 같은 코드 번들링 도구로도 import()를 잘 사용할 수 있다. 코드 번들러를 가장 단순하게 사용하는 방법은 프로그램의 진입점을 설정하고 번들러가 정적 import 지시자를 모두 찾아 큰 파일 하나로 바꾸게 하는 것이다. 하지만 동적 import()호출을 잘 사용하면 단단히 자인 번들 하나를 더 짝은 번들 세트로 나눠 필요에 따라 불러오게 바꿀 수있다.
{% endhint %}

## import.meta.url

{% hint style="info" %}
ESM의 특별한 문법 import.meta는 현재 실행중인 모듈에 관한 메타데이터를 담은 객체를 참조한다. 일반적인 \<script>나 require()로 불러온 노드 모듈에서는 불가능하다. 이 객체의 url 프로퍼티는 모듈을 불러온 URL이며 노드에서는 file://URL이다.&#x20;

import.meta.url의 대표적인 사용처는 모듈과 같은 디렉터리, 또는 그 디렉터리에 상대적인 경로를 통해 이미지, 데이터 파일 , 기타 지원을 참조하는 것이다. URL() 생성자를 사용하면 상대 URL을 import.meta.url 같은 절대 URL을 기준으로 쉽게 해석할 수 있다. 예를 들어 지역에 맞게 변환해야 할 문자열이 포함된 모듈이 있고 그 지역화 파일은 모듈과 같은 l10n/ 디렉터레에 저장됐다고 하면 다음과 같은 함수를 만들어 문자열을 가져올 URL을 얻을 수 있다.
{% endhint %}

```javascript
function localStringURL(locale) {
  return new URL(`l10n/${locale}.json`, import.meta.url)
}
```
