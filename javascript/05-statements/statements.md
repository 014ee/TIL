# Statements

## 🐇 **문이란?**

{% hint style="info" %}
**실행을 통해 어떤 동작을 수행하는 명령어 혹은 문장**을 의미한다. 자바스크립트 인터프리터는 기본적으로 문을 작성된 순서대로 실행하지만, 다양한 제어문을 통해 기본 실행 순서를 바꾸어 동작시킬 할 수 있다.
{% endhint %}

## 🐇 표현문

{% hint style="info" %}
자바스크립트에서 가장 단순한 문은 부수 효과가 있는 표현식이다. **할당이나 함수 호출처럼 부수 효과가 있는 표현식은 그 자체로 문**이 될 수 있다.
{% endhint %}

```
const greeting = 'hello' + name;
counter++;
delete person.tel;
console.log('hello world');
displaySpinner();
```

> **함수 호출도 표현문일 수 있다.**
>
> 함수 호출은 표현식이지만 일반적으로 프로그램의 상태나 호스트 환경에 영향을 미치는 부수 효과가 있으므로 표현문으로 볼 수 있다. (함수에 부수 효과가 없다면 더 큰 표현식이나 할당문의 일부가 아닌 한 호출할 의미가 없다.)

## 🐇 복합문

{% hint style="info" %}
표현식 여러개를 하나로 묶는 콤마 연산자와 마찬가지로 문 여러 개를 문 블록이라고 하는 **중괄호로 묶어 문이 하나인 것 처럼 동작시는 복합문**을 만들 수 있다. 문 블록은 세미콜론으로 끝나지 않는다.
{% endhint %}

```
{
  x = Math.PI;
  cx = Math.cos(x);
  console.log('cos = ' + cx);
}
```

## 🐇 빈 문

{% hint style="info" %}
문이 있을 것으로 예상되는 곳에 문을 쓰지 않을 수도 있다. 자바스크립트 인터프리터는 빈 문을 실행할 때 아무 일도 하지 않으므 **빈 바디를 갖는 루프를 만들고자 할 때 유용**하다. 빈 문을 사용할 때는 의도치 않게 찾기 힘든 **버그가 생기는 것을 방지하기 위해 명시적으로 주석을 작성**해주는 것이 좋다.
{% endhint %}

```
for(let i = 0; i < a.length; a[i++] = 0) /* 의도적으로 비움 */ ;
```

## 🐇 debugger

{% hint style="info" %}
디버거 프로그램(개발자 도구 )이 실행중이라면 해당 문을 만났을 때 자바스크립트 코드 실행을 멈춤으로써 디버깅 동작을 실행할 수 있다.(자동으로 실행 x) 이 중단점 기능을 활용해 디버거에서 변수 값을 출력하거나 콜스택을 살펴보고, 좀 더 쉽게 디버깅 할  있다.&#x20;
{% endhint %}

```
function func(obj) {
  if(obj === undefined) debugger; 
  ...
}
```

## 🐇 'use strict' (ES5)

{% hint style="info" %}
'use strict'는 ES5에서 도입한 지시자이다. 이 지시자는 **스크립트나 함수 바디의 맨 처음에만 존재할 수 있고 앞에 실제 문이 있어서는 안된다.** 'use strict'를 사용하면 그 이후의 코드가 스트릭트 모드를 따르는 코드가 된다. 이로써 **자바스크립트의 중요한 결함을 수정하고 더 강력히 에러를 체크하며 보안을 강화**할 수 있다.



\*\*Class나 ES6 모듈로 작성한 자바스크립트 코드는 자동으로 스트릭트 모드를 따르므로 'use strict' 지시자를 사용할 필요가 없다.
{% endhint %}

* 스트릭트 모드에서는 <mark style="background-color:yellow;">**with 문을 허용하지 않는다.**</mark>** **<mark style="background-color:purple;"><mark style="color:red;background-color:yellow;">****<mark style="color:red;background-color:yellow;"></mark>&#x20;
* 스트릭트 모드에서는 반드시 모든 변수를 선언해야 한다. <mark style="background-color:yellow;">**선언되지 않은 식별자에 값을 할당할 경우 ReferenceError**</mark>가 발생한다. (일반 모드에서는 전역 객체에 새 프로퍼티를 추가하는 묵시적인 방식으로 전역 변수를 선언한다.)
* 스트릭트 모드에서는 <mark style="background-color:yellow;">**메서드가 아닌 함수로 호출된 함수의 this 값은 undefined**</mark>이다. (일반 모드에서 함수로 호출된 함수의 this는 항상 전역 객체이다.)&#x20;
*
* 스트릭트 모드에서 함수를 **call()이나 apply()로 호출하면 해당 함수의 this 값은 call()이나 apply()에 전달된 첫번째 인자**이다. (일반 모드에서는 null 이나 undefined 값이 전역 객체로 대체되며 객체가 아닌 값은 객체로 변환된다.)
* 스트릭트 모드에서는 **읽기 전용인 프로퍼티에 할당하려 하거나 확장 불가능한 객체에 새 프로퍼티를 생성하려 하면 TypeError**가 발생한다. (일반 모드에서는 예외를 일으키지 않고 조용히 실패한다.)
* 스트릭트 모드에서는 **eval()에 전달된 코드는 호출자의 스코프에 변수를 선언하거나 함수를 정의할 수 없으며 대신 eval()을 위해 새로 생성된 스코프에 변수나 함수가 생성**된다.&#x20;
* 스트릭트 모드에서 **함수의 Arguments 객체는 함수에 전달된 값을 정적으로 복사 유지**한다.\
  (일반 모드에서 Arguments 객체는 배열 요소와 이름 붙은 함수 매개변수가 같은 값을 참조하는 마술 같은(?) 동작 방식을 갖는다.)
* 스트릭트 모드에서는 **delete 연산자 뒤에** 변수, 함수, 매개변수 등 **유효하지 않은 식별자를 사용할 때 SyntaxError**가 발생한다. (일반 모드에서는 아무 일도 일어나지 않고 false로 평가된다.)
* 스트릭 모드에서는 **변경 불가인 프로퍼티를 삭제하려 하면 TypeError**가 발생한다.\
  (일반 모드에서는 시도가 실패하고 delete 표현식은 false로 평가된다.)
* 스트릭트 모드에서는 **객체 리터럴을 써서 두 개 이상의 프로퍼티를 같은 이름으로 정의하려 하면 SyntaxError**가 발생한다. (일반 모드에서는 에러가 일어나지 않는다.)
* 스트릭 모드에서는 **8진수 정수 리터럴(0으로 시작하되 x가 없는)이 허용되지 않는다.**\
  ****(일반 모드에서는 일부 실행 환경에서 8진수 리터럴을 허용한다.)
* 스트릭트 모드에서는 **eval과 argument 식별자가 키워드로 취급**되며 그 값을 바꿀 수 없다.
* 스트릭 모드에서는 **콜스택을 살펴보는 것이 제한**된다. arguments.caller 와 arguments.callee는 모두 스트릭트 모드 함수에서 TypeError을 일으킨다. 함수의 caller 와 arguments 프로퍼티를 읽으려 해도 TypeError가 발생한다.
