# Functions

## 🐇 함수란?

{% hint style="info" %}
함수는 한번 정의하면 몇 번이고 호출할 수 있는 자바스크립트 코드 블록이다. 자바스크립트 **함수는 객체**이므로 함수를 변수에 할당하거나 다른 함수에 전달할 수 있다. 또한 함수의 프로퍼티를 정의할 수 있고 함수의 프로퍼티인 메서드를 호출하는 것 역시 가능하다.&#x20;
{% endhint %}

## 🐇 함수 정의

{% hint style="info" %}
자바스크립트 함수를 정의하는 가장 단순한 방법은 function 키워드를 이용하는 것이다. 이 키워드는 선언으로도, 표현식으로도 사용할 수 있다. ES6는 function 키워드 없이 함수를 정의하는 새로운 방법인 화살표 함수를 도입하였다. 이 문법은 매우 간결하며 함수를 다른 함수에 인자로 전달할 때 특히 유용하다.
{% endhint %}

> **함수 선언**
>
> **함수 선언은 function 키워드, 새로 정의한 함수 객체를 할당할 식별자, 함수 바디 안에서 로컬 변수로 동작할 0개 이상의 식별자 리스트, 함수를 호출할 때 마다 실행될 함수 바디로 구성**되어 있다.\
> 함수 선언문은 자신을 포함하는 스크립트, 함수, 또는 블록 맨 위로 끌어올려지므로 함수 선언문으로 정의한 함수는 평가되기 전에 호출할 수 있다.&#x20;

```
function factorial(x) {
  if(x <= 1) return 1;
  return x * factorial(x-1); // 팩토리얼을 계산하는 재귀 함수
}
```

{% hint style="info" %}
**ES5 이전의 함수 선언**

ES5 이전에는 자바스크립트 파일이나 다른 함수의 최상위 레벨에서만 함수를 선언할 수 있었다. 이 규칙을 우회하는 실행환경(루프나 조건문, 기타 블럭)이 존재하긴 했지만 엄밀히 말해 규칙을 어기는 것이었다.  ES6 스트릭트 모드에서는 블록 안에서 함수를 선언할 수 있으며, 이렇게 블록 안에서 정의된 함수는 해당 블록 안에서만 존재하며 블록 바깥에서는 볼 수 없다.
{% endhint %}

> **함수 표현식**
>
> 함수 표현식은 함수 선언과 거의 비슷하지만, 더 큰 표현식이나 문의 일부로 존재하고 이름을 붙이지 않아도 된다는 점이 다르다. 표현식으로 정의한 함수에 이름을 붙이는 것은 선택사항이다. 이름을 붙이는 경우 함수 선언이 실제로 변수를 선언하여 그 변수에 함수 객체를 할당한다면, 함수 표현식은 변수를 선언하지 않고 단지 로컬 함수 스코프에서 그 이름으로 함수 객체를 참조한다. 즉, 함수 표현식에서 함수 이름은 함수 안에서 로컬 변수로 쓸 수 있다.&#x20;

```
// 함수 표현식을 쓸 때는 실수로 함수를 덮어쓰지 않도록 const를 사용하는 것이 좋다.
const f = function factorial(x) {  // 
  if(x <= 1) return 1;
  return x * factorial(x-1); 
}
```

{% hint style="info" %}
**함수 선언과 함수 표현식의 호출 차이**

선언 형태를 사용하면 함수 객체는 자신을 포함하는 코드가 실행되기 전에 존재하므로 정의하기 전에 호출할 수 있다. 반면 표현식으로 정의된 함수는 실제로 평가되어 변수에 할당된 이후에 참조할 수 있다.  따라서 변수/상수와 동일하게 정의하기 전에 호출할 수 없다. (스트릭트 모드 기준)&#x20;
{% endhint %}

> **화살표 함수 (ES6)**
>
> 화살표 함수는 문이 아니라 표현식이므로 function 키워드를 사용하지 않으며 함수 이름도 필요 없다 .   화살표 함수는 간결하므로 함수를 다른 함수에 전달할 때 이상적이며, map(), filter(), reduce() 같은 배열 메서드를 사용할 때 이런 형태를 자주 사용한다. (화살표 함수를 작성할 때 함수 매개변수와 => 사이에서 줄바꿈을 해서는 안되며 만약 줄바꿈을 한다면 의도와 달리 문법적으로 유효한 할당문이 만들어진다.)

```
const a = x => {return {value: x};};  // {value: x}
const b = x => ({value: x});          // {value: x}
```

{% hint style="info" %}
**화살표 함수의 this**

다른 방법으로 정의된 함수는 호출시 자신만의 호출 컨텍스트를 정의하지만, 화살표 함수는 자신이 정의된 환경의 this 키워드 값을 상속받는다는 결정적인 차이가 있다. 이것은 화살표 함수에서 중요하고 아주 유용한 기능이다. 또한 화살표 함수는 prototype 프로퍼티가 없으므로 새로운 클래스의 생성자 함수로 사용할 수 없다.
{% endhint %}

> **중첩된 함수**
>
> 중첩된 함수에서 흥미로운 것은 변수 스코프 규칙인데, 중첩된 함수는 자신을 포함하는 함수들의 매개변수와 변수에 접근할 수 있다.

```
function print(x, y) {
  function maxNum(n1, n2) {return Math.max(n1, n2);}
  console.log(maxNum(x, y));
}
print(3, 8);  // 8
```

{% hint style="info" %}
자바스크립트 함수는 다른 함수 안에서 정의할 수 있으며 이렇게 정의된 함수는 자신이 정의된 스코프의 변수에 접근할 수 있다. 이런 의미에서 자바스크립트의 함수는 클로저이다.
{% endhint %}



## 🐇 함수 호출

{% hint style="info" %}
&#x20;함수 바디를 구성하는 자바스크립트 코드는 함수를 호출할 때 실행되며, 다음과 같은 다섯 가지 방법으로 호출할 수 있다.
{% endhint %}

> **함수로 호출**
>
> 함수는 호출 표현식을 통해 함수 또는 메서드로 호출된다. 함수 표현식이 프로퍼티 접근 표현식이라면, 즉 해당 함수가 객체 프로퍼티거나 배열 요소라면 이 표현식은 메서드 호출 표현식이다. 괄호 안에 들어있는 각 인자 표현식을 호출 시점에서 평가한 값이 인자가 되며, 함수 바디에서는 각 매개변수가 이에 대응하는 인자로 평가된다.&#x20;

```
const total = sum(0, 2) + sum(4, 5);
```

{% hint style="info" %}
**조건부 호출**

ES2020에서는 함수 표현식과 여는 괄호 사이에 ?.을 넣어서 함수가 null이나 undefined가 아닌 경우에만 호출할 수 있게 할 수 있다.&#x20;
{% endhint %}

{% hint style="info" %}
**함수의 호출 컨텍스트(this)**

일반 모드에서 함수의 호출 컨텍스트(this)는 전역 객체이다. 스트릭트 모드의 호출 컨텍스트는 undefined이다. 단, 화살표 문법으로 정의한 함수는 항상 자신이 정의된 곳의 this 값을 상속받은다. 메서드가 아니라 함수로 호출되도록 설계된 함수는 일반적으로 this 키워드를 전혀 사용하지 않는다. 하지만 this 키워드를 사용해서 스크릭트 모드에 있는지 확인하는 것은 가능하다.

const isStrict = (function() {return !this;})();  // 스트릭트 모드면 true 반
{% endhint %}

{% hint style="info" %}
**재귀함수와 스택**

&#x20;자기 자신을 호출하는 재귀함수를 통해 트리 기반 데이터 구조 같은 일부 알고리즘을 명쾌하게 구현할 수 있다. 자바스크립트 인터프리터가 호출된 함수의 실행 컨텍스트를 모두 추적하여 스택을 관리하므로 콜 스택도 메모리를 사용하며 최신 하드웨어에서는 일반적으로 재귀 함수가 자신을 수백번 호출하는 정도는 문제가 되지 않지만 수만번 호출한다면 '콜스택 크기가 한도에 도달했습니다'는 에러 메시지를 나타내므로 메모리를 고려하여야 한다.&#x20;



가령 어떤 함수가 자신을 재귀적으로 100번 호출하면 스택에는 객체 100개가 쌓이고 다시 객체 100개를 꺼내햐 한다.
{% endhint %}

> **메서드로 호출**
>
> 메 서드는 객체 프로퍼티로 저장된 함수다. 다음과 같이 함수를 객체의 메서드로 정의할 수 있다. 메서드의 호출 인자와 반환값은 일반적인 함수 호출과 똑같다. 하지만 메서드 호출과 함수 호출은 호출 컨텍스트가 다르다는 중요한 차이가 있다. 메서드 호출 표현식에서는 메서드가 정의되어 있는 객체가 호출 컨텍스트가 되고, 함수 바디는 키워드 this를 통해 그 객체를 참조할 수 있다. 메서드 호출은 대부분 점 표기법을 통해 프로퍼티에 접근하지만 대괄호 표현식으로도 메서드를 호출할 수 있다.
>
>

```
const obj = {
 name: 'Lee',
 age: 30,
}
const greeting = function() {
  return `hello, ${this.name}!`
}
const obj.method = greeting;

obj.method();  // 'hello, Lee!
```

> 메서드와 this 키워드는 객체 지향 프로그래밍 패러다임의 핵심이다. 메서드로 ㅏ용되는 함수는 모두 자신을 호출하는 객체를 묵시적인 인자로 받는다. 메서드는 일반적으로 그 객체에서 동작하며, 메서드 호출 문법은 함수가 객체에서 동작한다는 의미를 명쾌하게 전달한다.

```
rect.setSize(width, height);       // 아래 함수보다 훨씬 구조가 명쾌해보인다.
setRectSize(rect, width, height);
```

{% hint style="info" %}
&#x20;**메서드 체인**

메서드가 객체를 반환하면 그 반환 값에서 다시 메서드를 호출할 수 있다. 이렇게 메서드 호출을 체인으로 이어서 표현식 하나로 만들 수 있는데 이를 메서드 체인이라고 한다. 반환 값이 필요 없는 메서드를 작성할 때 메서드가 this를 반환하도록 하여 API 전체에서 일관되게 this를 반환한다면 메서드 체인이라는 프로그램을 스타일을 따를 수 있다. 이런 스타일에서는 다음과 같이 객체를 한 번만 참조하고도 연속으로 메서드를 호출할 수  있다.&#x20;

new Square().x(100).y(100).size(50).fill('blue').draw();



this는 변수나 프로퍼티 이름이 아니라 키워드 이므로 자바스크립트 문법에서는 this에 값을 할당할 수 없다. 또한 this 키워드는 변수의 스코프 규칙을 따르지 않는다. 화살표 함수의 예외를 제외하면 중첩된 함수는 포함하는 함수의 this 값을 상속받지 않는다. 중첩된 함수를 메서드로 호출하면 그 this 값은 호출한 객체이다. (화살표 함수가 아닌) 중첩된 함수를 함수로 호출하면 그 this 값은 일반 모드에서는 전역 객체이고, 스트릭트 모드에서는 undefined 이다. 메서드 안에 정의된 함수를 함수로 호출하면 this를 통해 메서드의 호출 컨텍스트를 참조할 수 있다고 생하기도 하는데 이는 흔히 저지르는 실수이다.&#x20;

d아래 예시에서 중첩된 함수 f() 에서 this 키워드는 객체 obj와 다르다. 이것은 자바스크립트 언어의 결함으로 지적받는 부분이고, 반드시 인지하고 있어야 한다. 아래 코드는 널리 쓰이는 우회 방법을 제시하는 코드인데, 메서드 method 안에서 this 값을 변수 self에 할당하면, 중첩된 함수 f 안에서 포함하는 객체를 this 대신 self로 참조할 수 있다.
{% endhint %}

```
let obj = {
  method() {
    let self = this; // this 값을 변수에 저장
    this === obj;    // true: this는 객체 obj이다.
    f();
    
    function f() {   // 중첩된 함수 f
      this === obj;  // false: this는 전역 객체이거나 undefined이다.
      self === obj;  // true: self는 외부 this 값이다.
    }
  }s
}
obj.method()
```

{% hint style="info" %}
&#x20;ES6 이후에는 중첩된 함수 f 를 화살표 함수로 변환해 this 값을 상속하게 하는 방법도 가능하다. 표현식으로 정의된 함수는 끌어올려지지 않으므로 해당 코드가 동작하기 위해서는 메서드 method 안에서 f 를 정의하는 부분을 호출 이전으로 옮겨야 한다.&#x20;
{% endhint %}

```
const f = {
  this === obj; // true: 화살표 함수는 항상 this를 상속받는다.
}
```

{% hint style="info" %}
또는 중첩된 함수의 bind() 메서드를 호출해 지정된 객체에서 묵시적으로 호출되는 새 함수를 정의는 방법도 있다.
{% endhint %}

```
const f = (function() {
  this === obj; // true: 이 함수를 외부 this와 연결
}).bind(this);
```

> **생성자로 호출**
>
> &#x20;함수나 메서드를 출할 때 앞에 키워드 new를 붙이면 생성자로 호출된다. 생성자 호출은 인자 처리, 호출 컨텍스트, 반환 값 등에서 일반적인 함수나 메서드 호출과 다르다.
>
> * 생성자를 호출할 때 괄호 안에 인자 리스트가 있으면 이 인자 표현식을 평가하여 함수나 메서드 출과 같은 방법으로 함수에 전달한다. (자주 쓰는 방식은 아니지만 생성자 호출에서는 빈 괄호를 생략해도 된다.)
> * 생성자를 호출하면 생성자의 prototype 프로퍼티에서 지정된 객체를 상속받는 빚 객체가 새로 생성된다. 생성자 함수는 객체를 초기화할 의도로 만들어졌으며, 이렇게 새로 생성된 객체가 호출 컨텍스트로 사용되므로 생성자 함수는 새 객체를 this 키워드로 참조할 수 있다. (즉 생성자 호출이 메서드 호출처럼 보이더라도 호출 컨텍스트는 새 객체이다.)
> * 생성자 함수는 일반적으로 return 키워드를 사용하지 않는다. 일반적으로 새 객체를 초기화하며 함수 바디의 끝에 도달하면 종료된다. 이 경우 만들어진 새 객체가 생성자 호출 표현식의 값이다. 하지만 생성자가 명시적으로 return 문을 사용해 객체를 반환한다면 그 객체가 호출 표현식의 값이 된다. (생성자가 return문을 값 없이 사용하거나 기본 값을 반환한다면 반환 값을 무시하고 새 객체를 표현식의 값으로 사용한다.)

```
obj = new Object();
obj = new Object;
obj = new o.m();     // 호출 컨텍스트는 객체 o가 아니라 새 객체다.
```

> **call(), apply()메서드를 통해 간접적으로 호출**
>
> 자바스크립트 함수는 객체이며 다른 자바스크립트 객체와 마찬가지로 메서드가 있다. 이 메서드 중 call()과 apply()는 함수를 간접적으로 호출한다. 두 메서드 모두 호출 시점에 this 값을 직접 명시할 수 있으므로 함수를 어떤 객체의 메스드로도 호출할 수 있다. call() 메서드는 인자 리스트를 받고 apply() 메서드는 인자로 배열을 받는다.

> **묵시적 함수 호출**
>
> 자바스크립트에는 함수 호출처럼 보이지 지만 함수를 호출하는 기능이 여럿 존재한다. (묵시적으로 호출한 함수에서 버그, 부작용, 성능 문제가 발생할 경우 단순히 코드를 들여다보는 것으로는 언제 호출되는지 명확히 알기 어려우므로 일반적인 함수에 비해 해결하기가 훨씬 어렵다.)
>
> * 객체에 게터나 세터가 있다면 프로퍼티 값에 접근할 때 이 메서드가 호출될 수 있다.
> * 문자열을 받는 컨텍스트에 객체를 사용하면 toString() 메서드가 자동 호출된다.
> * 마찬가지로 숫자를 받는 컨텍스트에 객체를 사용하면 valueOf() 메서드가 자동 호출된다.
> * 이터러블 객체의 요소를 순회할 때 여러가지 메서드가 호출될 수 있다.
> * 태그된 템플릿 리터럴도 함수 호출을 일으킬 수 있다.
> * 프록시 객체는 완전히 함수에 의해 제어되며, 이런 객체에는 어떤 동작을 취하든 항상 함수가 호출된다.

{% hint style="info" %}
**함수 호출컨텍스**

각 함수 호출 시 호출 컨텍스트가 생성되는데 이것이 this의 키워드 값이다.  객체 프로퍼티로 할당된 함수를 객체의 메서드라고 부르며 객체를 통해 함수를 호출하면, 그 객체가 호출 컨텍스트 즉 함수의 this 값이 된다.
{% endhint %}

## 🐇 함수 매개변수

{% hint style="info" %}
&#x20;자바스크립트 함수는 호출 시 전달받은 인자의 타입이나 갯수를 체크하지 않으므로 함수가 부적절한 인자로 호출되지 않도록 함수 바디에서 명시적으로 테스트하는 것이 좋다.
{% endhint %}

> **선택사항인 매개변수와 기본 값**
>
> &#x20;매개변수보다 적은 인자로 함수를 호출하면, 대응하는 인자가 없는매개변수는 기본값으로 정해지며 일반적으로 이 값은 undefined 이다. 선택사항인 인자를 받는 함수를 만들 때는 선택 사항인 인자 인자 리스트 마지막에 써서 생략하기 쉽게 만들어야 한다. ES6 이후에는 함수를 정의할 때 함수 매개변수의 기본 값을 정의할 수 있다. 매개변수 기본값 표현식은 함수를 정의할 때가 아니라 호출할 때 평가된다. 매개변수 기본 값을 사용하면 정의된 매개변수보다 적은 인자를 써서 함수를 호출할 수 있다.

```
function getPropertyNames(obj, arr) {
  if(arr == undefined) arr = [];  // 정의되지 않으면 빈 배열 할당
  for(let property in obj) arr.push(property);
  return arr;
}

// 위와 동일한 코
function getPropertyNames(obj, arr = []) {
  for(let property in obj) arr.push(property);
  return arr;
}
```

> **나머지 매개변수와 가변 길이 인자 리스트(ES6)**
>
> &#x20;정의된 매개변수 보다 더 많은 인자를 써서 함수를 호출할 때 나머지 매개변수를 사용할 수 있다. 나머지 매개변수는 앞에 점 세개(...)를 붙이는데, 반드시 함수 선언에서 마지막으로 정의된 매개변수여야 한다. 함수 바디 안에서 나머지 매개변수의 값은 항상 배열이며, 배열이 비어있더라도 나머지 매개변수는 절대 undefined가 되지 않는다. 따라서 나머지 매개변수에 매개변수 기본 값을 지정할 필요도 없고 허용되지도 않는다.&#x20;

```
// 아래 함수처럼 인자 개수에 제한이 없는 함수를 가변함수라고 한다.
function max(first = -Infinity, ...rest) { 
  let maxValue = first;
  for(let num of rest) {
    if(num > maxValue) {
      maxValue = num;
    }
  }
  return maxValue;
}

max(1, 10, 100, 2, 3, 1000, 4, 5, 6); // 1000
```

> **Argument 객체 => 사용X(나머지 매개변수로 대체 가능)**
>
> 나머지 매개변수가 도입되기 전에는 Arguments 객체를 사용해서 가변 함수를 만들었다. 함수 바디 안에서 식별자 arguments는 해당 호출의 Arguments 객체를 참조한다. Arguments 객체는 배열 비슷한 객체이며, 함수에 전달된 인자 값을 이름이 아닌 숫자로 참조할 수 있게 한다. Arguments 객체는 자바스크립트 초기 버전부터 있었지만, 이상하게 동작하고 비효율적이며 최적화하기도 어렵다. 때문에 나머지 매개변수를 활용하는 편이 좋다.&#x20;

```
function max(x) {
  let maxValue = -Infinity;
  for(let i =; i< arguments.length; i++) {
    if(arguments[i] > maxValue) maxValue = arguments[i];
  }
  return maxValue;
}

max(1, 10, 100, 2, 3, 1000, 4, 5, 6); // 1000
```

> **함수 호출과 분해 연산자**
>
> &#x20;... 문법(분해 연산자)은 배열 리터럴과 함수 호출에 사용할 수 있는 특별한 자바스크립트 문법으로, 함수에 개별 값이 예상되는 컨텍스트에서 배열이나 문자열 같은 이터러블 객체를 분해한다. ...는 여러개의 인자를 배열에 모으며, 나머지 매개변수와 분해연산자를 함께 쓰면 유용한 경우가 많다.&#x20;

```
function timed(func) {  // 이 함수는 함수를 받아 래퍼 버전을 반환한다.
  return function(...args) {
    let startTime = Date.now();
    try{
      return func(...args);
    }
    finally {
      console.log(`실행시간(ms): ${Date.now() - startTime}`);
    }
  }
}

function benchmark(num) { // 이 함수는 1과 n 사이의 숫자 합을 계산한다.
  let sum = 0;
  for(let i = 1; i<= num; i++) sum += i;
  return sum;
}

timed(benchmark)(10000000); // 50000005000000, 실행시간(ms):10
```

> **함수 인자를 매개변수로 분해**
>
> &#x20;함수를 정의할 때 매개변수 이름을 대괄호 안에 쓰면, 대괄호 한쌍마다 배열 값을 받는다고 정의하게 되고, 호출 과정에서 배열 인자는 개별 매개변수로 분해된다. 마찬가지로 객체 인자를 받는 함수를 정의할 때도 인자로 받은 객체를 매개변수로 분해할 수 있다. 객체와 배열인자만 분해할 수 있는 것은 아니다. 객체 배열, 배열 프로퍼티를 가진 객체, 객체 프로퍼티를 가진 객체 모두 분해할 수 있으며 그 깊이에 제한은 없다.

```
function drawCircle({x, y, radius='50%', color: [r, g, b]}) {
  // 함수 바
}
```

> **인자 타입**
>
> &#x20;자바스크립트 함는 매개변수 타입을 선언하지 않으며 값을 전달할 때도 타입을 체크하지 않으므로 함수 인자에 뜻이 분명한 이름을 쓰고 함수에 주석을 달아두면 코드 자체가 문서가 될 수 있다. 함수를 정의한 곳 근처에서 호출하는 함수가 아닌 한, 인자 타입을 체크하는 코드를 추가하는 편이 좋다. 함수가 잘못된 값을 받은 채 실행을 시작하고 명확하지 않은 에러 메시지를 보내며 실패하는 것보다는, 예측 가능한 형태로 즉시 실패하는 편이 더 좋다.

```
function sum(arr) {
  let tatal = 0;
  for(let item of arr) {  // arr가 이터러블이 아니면 TypeError가 발생한다.
    if(typeof item !== 'number') {
      throw new TypeError('sum(): items must be numbers');
    }
    total += item;
  }
  return total;
}

sum([1, 2, 3]);    // 6
sum([1, 2, '3']);  // TypeError: '3'은 숫자가 아니다.
```

## 🐇 값인 함수

{% hint style="info" %}
자바스크립트 함수는 문법일 뿐 아니라 값(데이터)이기도 하다. 때문에 변수에 할당하거나 객체 프로퍼티나 배열 요소에 저장할 수도 있으며, 다른 함수에 인자로 전달할 수도 있다.&#x20;
{% endhint %}

> &#x20;함수 프로퍼티 직접 정의
>
> 자바스크립트 함수는 기본 값이 아니라 특별한 객체이므로 함수 역시 프로퍼티를 가질 수 있다. 함수를 언제 호출하든 일정한 정적 변수가 필요하다면 그 변수를 함수 자체의 프로퍼티로 정의하면 편리하다.&#x20;

```
// 호출할 때 마다 서로 다른 고유한 정수를 반환하는 함수 예시
uniqueInteger.counter = 0;
function uinqueInteger() {
  return uniqueInterget.counter++;   // counter 프로퍼티를 반환하고 증가시킨다.
}
```

```
// 팩토리얼을 계산하고 그 결과를 함수 자체 프로퍼티로 캐시하는 함수 예시
fucntion fatorial() {
  if(Number.isInteger(n) && n > 0) {       // 양의 정수만 사용
    if(!(n in factorial)){                 // 캐시된 결과가 없다면
      factorial[n] == n * factorial(n-1);  // 계산 후 캐시에 저장
    }
    return factorial[n];                   // 캐시된 결과를 반환
  } esle {
    return NaN;                            // 입력이 잘못된 경우
  }
}
factorial[1] = 1; // 캐시 초기화
factorial(6);     // 720
factorial[5];     // 120: 캐시에 존재
```

{% hint style="info" %}
&#x20;클로저 활

uniqueInteger 함수의 경우 버그나 악의적인 코드에서 카운터를 리셋하거나 정수가 아닌 값으로 바꿔서 함수가 자신의 목적을 잃게 만들 수 있다는 단점이 있다. (이는 클로저가 함수 호출 시점의 로컬 변수를 캡처하여 이 변수를 비공개 상태로 사용할 수 있다는 점을 활용하여 개선할 수 있다.)
{% endhint %}

```
let uinqueInteger = (function() {
  let counter = 0;
  return function() {return counter++;}
}());
uinqueInteger(); // 0
uinqueInteger(); // 1
```
