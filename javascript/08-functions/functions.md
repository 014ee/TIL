# Functions

## 🐇 함수란?

{% hint style="info" %}
함수는 한번 정의하면 몇 번이고 호출할 수 있는 자바스크립트 코드 블록이다. 자바스크립트 **함수는 객체**이므로 함수를 변수에 할당하거나 다른 함수에 전달할 수 있다. 또한 프로퍼티를 정의할 수 있고 함수의 메서드를 호출하는 것도 가능하다.&#x20;
{% endhint %}

## 🐇 함수 정의

{% hint style="info" %}
자바스크립트 함수를 정의하는 가장 단순한 방법은 function 키워드를 이용하는 것이다. 이 키워드는 선언으로도, 표현식으로도 사용할 수 있다. ES6는 function 키워드 없이 함수를 정의하는 새로운 방법인 화살표 함수를 도입하였다. 이 문법은 매 간결하며 함수를 다른 함수에 인자로 전달할 때 특히 유용하다.
{% endhint %}

> **함수 선언**
>
> **함수 선언은 function 키워드, 새로 정의한 함수 객체를 할당할 식별자, 함수 바디 안에서 로컬 변수로 동작할 0개 이상의 식별자 리스트, 함수를 호출할 때 마다 실행될 함수 바디로 구성**되어 있다.\
> 함수 선언문은 자신을 포함하는 스크립트, 함수, 또는 블록 맨 위로 끌어올려지므로 함수 선언문으로 정의한 함수는 평가되기 전에 호출할 수 있다. 즉, 블록 안에서 선언된 함수의 경우 자바스크립트 인터프리터는 해당 블록의 코드를 실행하기 전에 함수를 정의하여 함수는 해 블록 전체에 존재하게 된다.

```
function factorial(x) {
  if(x <= 1) return 1;
  return x * factorial(x-1); // 팩토리얼을 계산하는 재귀 함수
}
```

{% hint style="info" %}
**ES5 이전의 함수 선언**

ES5 이전에는 자바스크립트 파일이나 다른 함수의 최상위 레벨에서만 함수를 선언할 수 있었다. 이 규칙을 우회하는 실행환경(루프나 조건문, 기타 블럭)이 존재하긴 했지만 엄밀히 말해 규칙을 어기는 것이었다.  ES6 스트릭트 모드에서는 블록 안에서 함수를 선언할 수 있다. 때문에 블록 안에서 정의된 함수는 해당 블록 안에서만 존재하며 블록 바깥에서는 볼 수 없다.
{% endhint %}

> **함수 표현식**
>
> 함수 표현식은 함수 선언과 거의 비슷하지만, 더 큰 표현식이나 문의 일부로 존재하고 이름을 붙이지 않아도 된다는 점이 다르다. 표현식으로 정의한 함수에 이름을 붙이는 것은 선택사항이며 함수 선언이 실제로 변수를 선언하여 그 변수에 함수 객체를 할당하는 반면 함수 표현식은 변수를 선언하지 않는다. 함수 표현식에 이름이 있으면, 로컬 함수 스코프에서 그 이름으로 함수 객체를 참조한다. 즉 함수 이름은 함수 안에서 로컬 변수가 된다.&#x20;

```
// 함수 표현식을 쓸 때는 실수로 함수를 덮어쓰지 않도록 const를 사용하는 것이 좋다.
const f = function factorial(x) {  // 
  if(x <= 1) return 1;
  return x * factorial(x-1); 
}
```

{% hint style="info" %}
**함수 선언과 함수 표현식의 중요한 차이**

선언 형태를 사용하면 함수 객체는 자신을 포함하는 코드가 실행되기 전에 존재하므로 정의하기 전에 호출할 수 있다. 반면 표현식으로 정의된 함수는 실제로 평가되어 변수에 할당된 이후에 참조할 수 다.  따라서 변수/상수와 동일하게 정의하기 전에 호출할 수 없다. (스트릭트 모드 기)&#x20;
{% endhint %}

> **화살표 함수 (ES6)**
>
> 화살표 함수는 문이 아니라 표현식이므로 function 키워드를 사용하지 않으며 함수 이름도 필요 없다 .  화살표 함수를 작ㅈ성할 때 함수 매개변수와 => 사이에서 줄바꿈을 해서 안되며 만약 줄바꿈을 한다면 의도와 달리 문법적으로 유효한 할당문이 만들어진다. 화살표 함수는 간결하므로 함수를 다른 함수에 전달할 때 이상적이며, map(), filter(), reduce() 같은 배열 메서드를 사용할 대 이런 형태를 자주 사용한다.

```
const a = x => {return {value: x};};  // {value: x}
const b = x => ({value: x});          // {value: x}
```

{% hint style="info" %}
**화살표 함수의 this**

다른 방법으로 정의된 함수는 자신만의 호출 컨텍스트를 정의하지만, 화살표 함수는 자신이 정의된 환경의 this 키워드 값을 상속받는다는 결정적인 차이가 있다. 이것은 화살표 함수에서 중요하고 아주 유용한 기능이다. 또한 화살표 함수는 prototype 프로퍼티가 없으므로 새로운 클래스의 생성자 함수로 사용할 수 없다.
{% endhint %}

> **중첩된 함수**
>
> 중첩된 함수에서 흥미로운 것은 변수 스코프 규칙인데, 중첩된 함수는 자신을 포함하는 함수들의 매개변수와 변수에 접근할 수 있다.

```
function print(x, y) {
  function maxNum(n1, n2) {return Math.max(n1, n2);}
  console.log(maxNum(x, y));
}
print(3, 8);  // 8
```

{% hint style="info" %}
자바스크립트 함수는 다른 함수 안에서 정의할 수 있으며 이렇게 정의된 함수는 자신이 정의된 스코프의 변수에 접근할 수 있다. 이런 의미에서 자바스크립트의 함수는 클로저이다.
{% endhint %}

## 🐇 함수 호출

{% hint style="info" %}
**함수 호출 컨텍스**

각 함수 호출 시 호출 컨텍스트가 생성되는데 이것이 this의 키워드 값이다.  객체 프로퍼티로 할당된 함수를 객체의 메서드라고 부르며 객체를 통해 함수를 호출하면, 그 객체가 호출 컨텍스트 즉 함수의 this값이 된다.
{% endhint %}

## 🐇 함수 매개변수



## 🐇 값인 함수



## 🐇 네임스페이스인 함수&#x20;

