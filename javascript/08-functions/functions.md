# Functions

## 🐇 함수란?

{% hint style="info" %}
함수는 한번 정의하면 몇 번이고 호출할 수 있는 자바스크립트 코드 블록이다. 자바스크립트 **함수는 객체**이므로 함수를 변수에 할당하거나 다른 함수에 전달할 수 있다. 또한 함수의 프로퍼티를 정의할 수 있고 함수의 프로퍼티인 메서드를 호출하는 것 역시 가능하다.&#x20;
{% endhint %}

## 🐇 함수 정의

{% hint style="info" %}
자바스크립트 함수를 정의하는 가장 단순한 방법은 function 키워드를 이용하는 것이다. 이 키워드는 선언으로도, 표현식으로도 사용할 수 있다. ES6는 function 키워드 없이 함수를 정의하는 새로운 방법인 화살표 함수를 도입하였다. 이 문법은 매우 간결하며 함수를 다른 함수에 인자로 전달할 때 특히 유용하다.
{% endhint %}

> **함수 선언**
>
> **함수 선언은 function 키워드, 새로 정의한 함수 객체를 할당할 식별자, 함수 바디 안에서 로컬 변수로 동작할 0개 이상의 식별자 리스트, 함수를 호출할 때 마다 실행될 함수 바디로 구성**되어 있다.\
> 함수 선언문은 자신을 포함하는 스크립트, 함수, 또는 블록 맨 위로 끌어올려지므로 함수 선언문으로 정의한 함수는 평가되기 전에 호출할 수 있다.&#x20;

```
function factorial(x) {
  if(x <= 1) return 1;
  return x * factorial(x-1); // 팩토리얼을 계산하는 재귀 함수
}
```

{% hint style="info" %}
**ES5 이전의 함수 선언**

ES5 이전에는 자바스크립트 파일이나 다른 함수의 최상위 레벨에서만 함수를 선언할 수 있었다. 이 규칙을 우회하는 실행환경(루프나 조건문, 기타 블럭)이 존재하긴 했지만 엄밀히 말해 규칙을 어기는 것이었다.  ES6 스트릭트 모드에서는 블록 안에서 함수를 선언할 수 있으며, 이렇게 블록 안에서 정의된 함수는 해당 블록 안에서만 존재하며 블록 바깥에서는 볼 수 없다.
{% endhint %}

> **함수 표현식**
>
> 함수 표현식은 함수 선언과 거의 비슷하지만, 더 큰 표현식이나 문의 일부로 존재하고 이름을 붙이지 않아도 된다는 점이 다르다. 표현식으로 정의한 함수에 이름을 붙이는 것은 선택사항이다. 이름을 붙이는 경우 함수 선언이 실제로 변수를 선언하여 그 변수에 함수 객체를 할당한다면, 함수 표현식은 변수를 선언하지 않고 단지 로컬 함수 스코프에서 그 이름으로 함수 객체를 참조한다. 즉, 함수 표현식에서 함수 이름은 함수 안에서 로컬 변수로 쓸 수 있다.&#x20;

```
// 함수 표현식을 쓸 때는 실수로 함수를 덮어쓰지 않도록 const를 사용하는 것이 좋다.
const f = function factorial(x) {  // 
  if(x <= 1) return 1;
  return x * factorial(x-1); 
}
```

{% hint style="info" %}
**\*\*함수 선언과 함수 표현식의 호출 차이**

선언 형태를 사용하면 함수 객체는 자신을 포함하는 코드가 실행되기 전에 존재하므로 정의하기 전에 호출할 수 있다. 반면 표현식으로 정의된 함수는 실제로 평가되어 변수에 할당된 이후에 참조할 수 있다.  따라서 변수/상수와 동일하게 정의하기 전에 호출할 수 없다. (스트릭트 모드 기준)&#x20;
{% endhint %}

> **화살표 함수 (ES6)**
>
> 화살표 함수는 문이 아니라 표현식이므로 function 키워드를 사용하지 않으며 함수 이름도 필요 없다 .   화살표 함수는 간결하므로 함수를 다른 함수에 전달할 때 이상적이며, map(), filter(), reduce() 같은 배열 메서드를 사용할 때 이런 형태를 자주 사용한다. (화살표 함수를 작성할 때 함수 매개변수와 => 사이에서 줄바꿈을 해서는 안되며 만약 줄바꿈을 한다면 의도와 달리 문법적으로 유효한 할당문이 만들어진다.)

```
const a = x => {return {value: x};};  // {value: x}
const b = x => ({value: x});          // {value: x}
```

{% hint style="info" %}
**화살표 함수의 this**

다른 방법으로 정의된 함수는 호출시 자신만의 호출 컨텍스트를 정의하지만, 화살표 함수는 자신이 정의된 환경의 this 키워드 값을 상속받는다는 결정적인 차이가 있다. 이것은 화살표 함수에서 중요하고 아주 유용한 기능이다. 또한 화살표 함수는 prototype 프로퍼티가 없으므로 새로운 클래스의 생성자 함수로 사용할 수 없다.
{% endhint %}

> **중첩된 함수**
>
> 중첩된 함수에서 흥미로운 것은 변수 스코프 규칙인데, 중첩된 함수는 자신을 포함하는 함수들의 매개변수와 변수에 접근할 수 있다.

```
function print(x, y) {
  function maxNum(n1, n2) {return Math.max(n1, n2);}
  console.log(maxNum(x, y));
}
print(3, 8);  // 8
```

{% hint style="info" %}
자바스크립트 함수는 다른 함수 안에서 정의할 수 있으며 이렇게 정의된 함수는 자신이 정의된 스코프의 변수에 접근할 수 있다. 이런 의미에서 자바스크립트의 함수는 클로저이다.
{% endhint %}



## 🐇 함수 호출

{% hint style="info" %}
&#x20;함수 바디를 구성하는 자바스크립트 코드는 함수를 호출할 때 실행되며, 다음과 같은 다섯 가지 방법으로 호출할 수 있다.
{% endhint %}

> **함수로 호출**
>
> 함수는 호출 표현식을 통해 함수 또는 메서드로 호출된다. 함수 표현식이 프로퍼티 접근 표현식이라면, 즉 해당 함수가 객체 프로퍼티거나 배열 요소라면 이 표현식은 메서드 호출 표현식이다. 괄호 안에 들어있는 각 인자 표현식을 호출 시점에서 평가한 값이 인자가 되며, 함수 바디에서는 각 매개변수가 이에 대응하는 인자로 평가된다.&#x20;

```
const total = sum(0, 2) + sum(4, 5);
```

{% hint style="info" %}
**조건부 호출**

ES2020에서는 함수 표현식과 여는 괄호 사이에 ?.을 넣어서 함수가 null이나 undefined가 아닌 경우에만 호출할 수 있게 할 수 있다.&#x20;
{% endhint %}

{% hint style="info" %}
**함수의 호출 컨텍스트(this)**

일반 모드에서 함수의 호출 컨텍스트(this)는 전역 객체이다. 스트릭트 모드의 호출 컨텍스트는 undefined이다. 단, 화살표 문법으로 정의한 함수는 항상 자신이 정의된 곳의 this 값을 상속받은다. 메서드가 아니라 함수로 호출되도록 설계된 함수는 일반적으로 this 키워드를 전혀 사용하지 않는다. 하지만 this 키워드를 사용해서 스크릭트 모드에 있는지 확인하는 것은 가능하다.

const isStrict = (function() {return !this;})();  // 스트릭트 모드면 true 반
{% endhint %}

{% hint style="info" %}
**재귀함수와 스택**

&#x20;자기 자신을 호출하는 재귀함수를 통해 트리 기반 데이터 구조 같은 일부 알고리즘을 명쾌하게 구현할 수 있다. 자바스크립트 인터프리터가 호출된 함수의 실행 컨텍스트를 모두 추적하여 스택을 관리하므로 콜 스택도 메모리를 사용하며 최신 하드웨어에서는 일반적으로 재귀 함수가 자신을 수백번 호출하는 정도는 문제가 되지 않지만 수만번 호출한다면 '콜스택 크기가 한도에 도달했습니다'는 에러 메시지를 나타내므로 메모리를 고려하여야 한다.&#x20;



가령 어떤 함수가 자신을 재귀적으로 100번 호출하면 스택에는 객체 100개가 쌓이고 다시 객체 100개를 꺼내햐 한다.
{% endhint %}

> **메서드로 호출**
>
> 메 서드는 객체 프로퍼티로 저장된 함수다. 다음과 같이 함수를 객체의 메서드로 정의할 수 있다. 메서드의 호출 인자와 반환값은 일반적인 함수 호출과 똑같다. 하지만 메서드 호출과 함수 호출은 호출 컨텍스트가 다르다는 중요한 차이가 있다. 메서드 호출 표현식에서는 메서드가 정의되어 있는 객체가 호출 컨텍스트가 되고, 함수 바디는 키워드 this를 통해 그 객체를 참조할 수 있다. 메서드 호출은 대부분 점 표기법을 통해 프로퍼티에 접근하지만 대괄호 표현식으로도 메서드를 호출할 수 있다.
>
>

```
const obj = {
 name: 'Lee',
 age: 30,
}
const greeting = function() {
  return `hello, ${this.name}!`
}
const obj.method = greeting;

obj.method();  // 'hello, Lee!
```

> 메서드와 this 키워드는 객체 지향 프로그래밍 패러다임의 핵심이다. 메서드로 ㅏ용되는 함수는 모두 자신을 호출하는 객체를 묵시적인 인자로 받는다. 메서드는 일반적으로 그 객체에서 동작하며, 메서드 호출 문법은 함수가 객체에서 동작한다는 의미를 명쾌하게 전달한다.

```
rect.setSize(width, height);       // 아래 함수보다 훨씬 구조가 명쾌해보인다.
setRectSize(rect, width, height);
```

{% hint style="info" %}
&#x20;**메서드 체인**

메서드가 객체를 반환하면 그 반환 값에서 다시 메서드를 호출할 수 있다. 이렇게 메서드 호출을 체인으로 이어서 표현식 하나로 만들 수 있는데 이를 메서드 체인이라고 한다. 반환 값이 필요 없는 메서드를 작성할 때 메서드가 this를 반환하도록 하여 API 전체에서 일관되게 this를 반환한다면 메서드 체인이라는 프로그램을 스타일을 따를 수 있다. 이런 스타일에서는 다음과 같이 객체를 한 번만 참조하고도 연속으로 메서드를 호출할 수  있다.&#x20;

new Square().x(100).y(100).size(50).fill('blue').draw();



this는 변수나 프로퍼티 이름이 아니라 키워드 이므로 자바스크립트 문법에서는 this에 값을 할당할 수 없다. 또한 this 키워드는 변수의 스코프 규칙을 따르지 않는다. 화살표 함수의 예외를 제외하면 중첩된 함수는 포함하는 함수의 this 값을 상속받지 않는다. 중첩된 함수를 메서드로 호출하면 그 this 값은 호출한 객체이다. (화살표 함수가 아닌) 중첩된 함수를 함수로 호출하면 그 this 값은 일반 모드에서는 전역 객체이고, 스트릭트 모드에서는 undefined 이다. 메서드 안에 정의된 함수를 함수로 호출하면 this를 통해 메서드의 호출 컨텍스트를 참조할 수 있다고 생하기도 하는데 이는 흔히 저지르는 실수이다.&#x20;

d아래 예시에서 중첩된 함수 f() 에서 this 키워드는 객체 obj와 다르다. 이것은 자바스크립트 언어의 결함으로 지적받는 부분이고, 반드시 인지하고 있어야 한다. 아래 코드는 널리 쓰이는 우회 방법을 제시하는 코드인데, 메서드 method 안에서 this 값을 변수 self에 할당하면, 중첩된 함수 f 안에서 포함하는 객체를 this 대신 self로 참조할 수 있다.
{% endhint %}

```
let obj = {
  method() {
    let self = this; // this 값을 변수에 저장
    this === obj;    // true: this는 객체 obj이다.
    f();
    
    function f() {   // 중첩된 함수 f
      this === obj;  // false: this는 전역 객체이거나 undefined이다.
      self === obj;  // true: self는 외부 this 값이다.
    }
  }s
}
obj.method()
```

{% hint style="info" %}

{% endhint %}





> **생성자로 호출**
>
>

> call(), apply()메서드를 통해 간접적으로 호출
>
>



> 자바스크립트 언어 기능을 통한 묵시적 호출
>
>



{% hint style="info" %}
**함수 호출컨텍스**

각 함수 호출 시 호출 컨텍스트가 생성되는데 이것이 this의 키워드 값이다.  객체 프로퍼티로 할당된 함수를 객체의 메서드라고 부르며 객체를 통해 함수를 호출하면, 그 객체가 호출 컨텍스트 즉 함수의 this 값이 된다.
{% endhint %}



## 🐇 함수 매개변수

{% hint style="info" %}
&#x20;
{% endhint %}



## 🐇 값인 함수



## 🐇 네임스페이스인 함수&#x20;

