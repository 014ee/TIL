# Let-Const-Var

{% hint style="info" %}
ES6 이후에 let과 const가 추가되었다. var은 호이스팅이나 함수 스코프 등로 인한 버그 발생 위험이 있어 var 대신 let과 const를 사용해 변수/상수를 선언하는 것이 권장된다.
{% endhint %}

## 🐇 let

{% hint style="info" %}
let 키워드는 변수를 선언할 때 사용한다. 자바스크립트에서는 루프 문법 자체의 일부로 루프 변수를 선언할 수 있도록 허용하는데, 이때 보통 let을 사용한다. (루프 바디에서 새 값을 할당하지 않는다면 const를 사용해도 된다.)
{% endhint %}

```
let i;         // 변수에 초기값을 할당하지 않으면 값은 할당 전까지 undefined로 남는다.
let x, y;      // let문 하나에 변수 여럿을 선언할 수도 있다.
let count = 0; // 변수를 선언할 때 초기값을 할당하는 것이 좋은 프로그래밍 습관이다.
```

## 🐇 const

{% hint style="info" %}
const 키워드는 상수를 선언할 때 사용한다. let과 거의 비슷하지만 상수를 바꾸려고 하면 TypeError가 발생하므로 선언할 때 반드시 값을 할당해 초기화해야 한다. 반드시 지켜야 하는 것은 아니지만 상수를 선언할 때 대문자를 써서 변수와 구별하는 관습이 있다.&#x20;
{% endhint %}

```
const MS_IN_A_DAY = 1000*60*60*24;  // 하루 단위 milliseconds 
```

{% hint style="info" %}
**언제 const를 쓰는가?**

첫번째로 프로그램 버전, 파일 타입을 식별할 때 사용하는 바이트 시퀀스처럼 기본적으로 바뀌지 않는 값에만 const 를 써야 한다는 의견과, 두번째로 일단 모든 것을 const로 선언한 다음 실제 값을 바꿔야 한다고 인식 했을 때 let 선언으로 바꾸는 것이 좋다는 의견이 있다. 개인적으로는 의도하지 않은 버그를 예방하려면 후자가 좋다고 생각한다.
{% endhint %}

## 🐇 **var**&#x20;

{% hint style="info" %}
ES6 전에는 변수를 선언하는 방법이 var 키워드 하나뿐이였으며 상수를 선언하는 방법은 없었다. var의 문법은 let과 똑같지만 아래와 같은 중요한 차이가 있다.
{% endhint %}

> * var 로 변수를 선언하면 이 선언문은 함수의 맨 위로 끌어올려진다. 따라서 var로 선언한 변수는 초기화 코드가 실행되기 전이라면 값이 undefined일수는 있지만 함수 어디서든 에러 없이 사용할 수 있다.
> * var로 선언한 변수는 얼마나 깊이 중첩됐든 상관 없이 함수 바디를 스코프로 갖는다.
> * var로 선언된 전역 변수는 let이나 const와 달리 전역 객체의 프로퍼티로 존재한다. (ex. globalThis.x) 또한 var로 선언된 전역 변수는 delete로 삭제할 수 없다.
> * var는 함수 스코프이므로 for 루프를 여러개 쓰는 함수에서 각 루프에서 같은 변수를 다시 선언하고 다시 초기화 할 수 있다.

```
var a = [1, 2, 3], count = a.length;
for(var i = 0; i < count; i++) console.log(a[i]);
```

## 🐇 스코프

{% hint style="info" %}
변수와 상수는 자신이 동작할 수 있는 유효한 범위를 갖는데 이 영역을 스코프라고 한다. 같은 스코프에서 같은 이름으로 let이나 const 선언을 하나 이상 하는 것은 문법 에러이다. (피해야 하는 일이기는 하지만 중첩된 스코프에서 같은 이름의 변수를 선언하는 것은 가능하다
{% endhint %}

> ### **let과 const는 블록 스코프**
>
> let과 const로 선언한 변수와 상수는 블록 스코프를 갖다. 자바스크립트의 클래스와 함수 정의, if/else, while, for 루프 바디는 블록이다. 즉, let과 const는 자신이 선언된 중괄호 안에서 유효하다는 의미이다. for, for/in, for/of 루프의 일부로 선언된 변수와 상수는 엄밀히 말해 중괄호 바깥에 존재하지만 그 스코프는 루프 바디이다.

> ### var는 함수 스코프
>
> var는 함수 스코프로 함수 내에서 선언되었을 경우에만 유효 범위를 갖는다. if/else, while, for 루프 바디 안에서 선언한 var는 스코프를 갖지 않기 때문에 외부에서 접근 가능하다.&#x20;

> ### 전역 스코프
>
> 선언이 어떤 코드 블록에도 속하지 않고 최상위 레벨에 있을 경우 이를 전역 변수 또는 상수라고 부르며, 이들은 전역 스코프를 갖는다. 노드와 클라이언트 사이드 자바스크립트 모듈에서 전역 변수의 스코프는 그 변수가 정의된 파일이다. 하지만 전통적인 클라이언트 사이드 자바스크립트에서 전역 변수의 스코프는 그 변수가 정의된 HTML 문서이다. 즉, 스크립트\<script>에서 전역 변수나 상수를 선언하면 그 변수나 상수는 해당 문서의 스크립트\<script> 전체에 존재한다.

{% hint style="info" %}
**var로 선언된 전역변수**

var로 선언된 전역변수는 전역 객체의 프로퍼티로 존재하므로 globalThis로 참조할 수 있다. 또한 delete로 삭제할 수 없다. (let과 const로 선언한 전역변수는 전역 객체의 프로퍼티가 아니다.)&#x20;
{% endhint %}

{% hint style="info" %}
**선언되지 않은 변수는 어떤 스코프일까?**

스트릭트 모드에서는 선언되지 않은 변수를 사용하면 코드 실행 시점에서 reference error가 일어난다. 스트릭트 모드가 아니라면 let, const, var로 선언하지 않은 이름에 값을 할당하려 해도 에러가 일어나지 않으며 전역 변수가 생성되기만 한다. 함수나 블록 내부가 얼마나 깊이 중첩됐는 상관 없이 전역이며, 이는 의도한 바가 아니므로 버그의 원인이 될 수 있다.  이렇게 실수로 생성된 전역변수는 var로 선언한 전역 변수와 마찬가지로 전역 객체의 프로퍼티가 되는데 var 과는 다르게 delete 연산자로 삭제할 수 있다.
{% endhint %}

## 🐇 분해 할당

{% hint style="info" %}
ES6 에서는 선언과 할당을 합친 일종의 복합 문법을 도입했으며 이를 분해 할당이라고 한다. 분해 할당에서 할당 연산자의 오른쪽에 있는 값에는 이터러블 객체가 들어올 수 있다. 왼쪽에 있는 값은 하나 이상의 변수 이름이며 배열이나 객체 리터럴 문법을 쓴다. 분해 할당이 일어나면 오른쪽 값에서 하나 이상의 값을 추출해 왼쪽에 있는 변수에 할당한다.
{% endhint %}

```
function calculation(x, y) {
  return [x + y, x - y];
}
const [add, sub] = calculation(20, 5);  // add: 25, sub: 15
```

> **배열 구조분해**
>
> 배열의 구조분해는 배열된 데이터 순서대로 이루어진다. 분해 할당에서 왼쪽에 있는 변수 갯수와 오른쪽에 있는 값의 갯수가 꼭 일치할 필요는 없다. 왼쪽의 변수가 남으면 undefined가 할당되고, 오른쪽 값이 남으면 무시된다. 왼쪽의 변수 리스트에 콤마를 추가로 넣어서 값 일부를 무시할 수도 있다. 또한 변수 이름 앞에 스프레드 연산(...)를 써서 배열을 분해하고 남은 값을 변수 하나에 모을 수도 있다. 또한 중첩된 배열에도 사용할 수 있다.

```
const [x, y, z] = [1, 2];        // x: 1, y: 2, z: undefined
const [x, y] = [1, 2, 3];        // x: 1, y: 2
const [x, , y] = [1, 2, 3];      // x: 1, y: 3
const [x, ...y] = [1, 2, 3];     // x: 1, y: [2, 3]
const [x, [y, z]] = [1, [2, 3]]; // x: 1, y: 2, z: 3

const obj = {a: 1, b: 2};
for(const [name, value] of Object.entries(obj)) {
  console.log(name, value);      // 'a 1', 'b 2'
} 
```

> **객체 구조분해**
>
> 객체 구조분해에서는 불러오는 객체의 속성명과 왼쪽에 있는 각 식별자의 이름 정확하게 일치해야 한다. 다른 이름을 사용하고 싶다면 다음과 같이 콜론(:)으로 새로운 이름에 값을 할당하 사용할 수 있다. (다만 변수와 프로퍼티 이름이 다르게 지정되면 코드를 읽는데 복잡해질 수 있다.) 왼쪽 객체로부터 할당받을 값이 없을 경우에는 할당 기호(=)를 통해 기본 값을 지정해 줄 수 있다.

```
const color = {black: '#111', orange: '#ff7300'};
const {black, orange: point, white = '#fff'} = color; 
```
