# Immutable-Primitive-Values

## 🐇 기본 타입 (불변)

{% hint style="info" %}
**숫자, 문자열, 불, 심벌(ES6), null, undefined** 만이 기본 타입이다.

기본 타입은 값 자체가 메모리에 저장되며, 입력한 값이 이미 메모리에 있으면 새롭게 메모리를 만들지 않고 해당 메모리 주소만 지정해준다. 또한 기본 타입은 불변이므로 값을 바꿀 수 없다. (예로 숫자 2를 3으로 바꾸는 것 불가능한 것과 같다.) 메서드 또한 값을 수정하는 것이 아닌 새 문자열을 반환한다. 문자의 경우 배열로 생각하여 바꿀 수 있다고 착각할 수 있는데, 자바스크립트에서 문자열은 읽기 전용 배열이므로 인덱스를 통해 문자열의 특정 텍스트에 접근할 수는 있지만 기존 문자열을 바꿀 수는 없다.&#x20;
{% endhint %}

## 🐇 숫자 Number

{% hint style="info" %}
자바스크립트는 IEEE 754 표준에서 정의하는 64비트 부동 소수점 형식을 사용해 숫자를 표현한다.&#x20;
{% endhint %}

> **정수 리터럴**
>
> 자바스크립트는 10진 정수 리터럴 뿐 아니라, 2진수(0b), 8진수(0o), 16진수(0x) 리터럴도 지원한다.

```
0b10101  // 21: 2진수 
0o377    // 255 8진수
0xff     // 255: 16진수
```

> **부동 소수점 리터럴**
>
> 부동 소수점 리터럴에는 소수점이 포함될 수 있으며, 지수 표기법으로도 표현할 수 있다.

```
3.14
.333333
6.02e25
1.4E-32
```

> **숫자 리터럴의 구분자**
>
> 다음과 같이 숫자 사이에 밑줄을 넣어 읽기 쉽게 구분할 수 있다.

```
const billion = 1_000_000_000  // 천 단위 구분자
const bytes = 0x89_AB_CD_EF    // 바이트 구분자
const bits = 0b0001_1101_0111  // 4비트 구분
```

> **자바스크립트의 산술 연산**
>
> 자바스크립트는 산술 연산자를 통해 숫자를 조작한다. 더하기, 빼기, 나누기, 나머지, 지수와 같은 기본 산술 연산자 외에도 Math 객체의 메서드를 통해 복잡한 수학 계산을 쉽게 적용할 수 있다.

```
1/0                    // Infinity
Number.MAX_VALUE * 2   // Infinity
-1/0                   // -Infinity
-Number.MAX_VALUE * 2  // -Infinity
0/0                    // NaN
Infinity/Infinity      // NaN
Number.Min_VALUE       // 0
-1/Infinity            // -0
```

{% hint style="info" %}
NaN는 자기 자신을 포함해 어떤 값과도 같지 않다. 즉, 변수 x의 값이 NaN인지 알아보기 위해 x === NaN를 사용할 수 없다. x != x 또는 Number.isNaN(x)를 사용해야 한다.
{% endhint %}

> **이진 부동 소수점 숫자와 반올림 오류**
>
> 자바스크립트를 비롯해 최신 프로그래밍 언어에서 사용하는 IEEE 754 부동 소수점 표현은 이진 표현이므로 1/2, 1/8, 1/1024같은 분수는 정확히 표현할 수 있지만 0.1 같은 단순한 숫자는 정확하게 표현하지 못하는 문제가 있다. 근삿값이 예상과 달라 프로그램에 문제가 생긴다면 정수로 변환하여 해결할 수 있다.

```
const x = 0.3-0.2  // 0.09999999999999998
const y = 0.2-0.1  // 0.1
x === y            // false
```

> **BigInt (ES2020)**
>
> 64비트 정수를 표현하기 위해 새로 추가된 기능으로, 연속된 숫자 다음 소문자 n을 붙인 형식이다. BigInt() 함수를 사용해 숫자나 문자열을 BigInt로 변환할 수 있으며, 일반적인 산술은 숫자와 유사하지만 나눗셈을 할 때 나머지를 버린다는 특징이 있다. BigInt와 일반적인 숫자는 범위가 다르므로 이 둘을 섞어서 산술 연산을 실행할 수 없다.&#x20;

```
1000n + 2000n // 3000n
2000n - 1000n  // 1000n
2000n * 3000n //6000000n
3000n / 977n  // 3n
3000n % 977n  // 9n
```

## 🐇 문자열 String

{% hint style="info" %}
자바스크립트 문자열은 16비트 값이 순서에 따라 이어진 형태이며, 각 값은 일반적으로 유니코드 문자이다. 문자열 메서드는 대부분 문자가 아니라 16비트 값 단위로 동작하므로 문자열의 길이는 문자의 갯수가 아니라 해당 문자열를 구성하는 16비트 값의 갯수이다.&#x20;
{% endhint %}

> **코드 포인트**
>
> 자바스크립트는 유니코드 문자셋의 UTF-16 인코딩을 사용한다. 자주 쓰이는 유니코드 문자의 코드 포인트는 보통 16비트 이내이므로 문자열 요소 하나로 표현할 수 있다. 반면 자주 쓰이지 않는 유니코드 문자의 코드 포인트는 16비트를 넘을 수 있으며, 이때 16비트 두개를 연속으로 쓰는 UTF-16 규칙(써로게이트 페어)로 인코드 된다. 즉, 유니코드 문자 하나의 length 값이 2가 될 수도 있다.

```
const heart = '💙'
heart.length // 2: UTF-16 인코딩 \ud83d\udc99
```

> **문자열 이스케이프 시퀀스 (ES5)**
>
> 작은 따옴표나 큰 따옴표로 감싼 문자열에서 역슬래시(\\)는 문자열에 표시할 수 없는 ' 나 " 같은 문자를 표현할 수 있게 하는 특별한 역할을 한다. (백틱 문법에서도 사용할 수 있지만 줄 끝 문자가 문자열 리터럴에 포함된다.)

```
'you\'re right, it can\'t be a quote'
```

```
\n      // 뉴라인
\t      // 탭
\'      // 작은 따옴표
\"      // 큰 따옴표
\\      // 역슬래시
\xnn    // 16진수 숫자 2개로 표현하는 유니코드 문자
\unnnn  // 16진수 숫자 4개로 표현하는 유니코드 문자
\u{n}   // 코드포인트 n으로 표현하는 유니코드 문자 
```

> **태그된 탬플릿 리터럴**
>
> 백틱 바로 앞에 함수 이름이 있으면 템플릿 리터럴의 텍스트와 표현식 값이 함수에 전달되는데, 이러한 구조를 가진 코드를 태그된 템플릿 리터럴이라고 한다.

```
`\n`.length            // 1
String.raw`\n`.length  // 2: String.raw는 이스케이프를 처리하지 않고 문자 그대로 반환 
```

## 🐇 불 Boolean

{% hint style="info" %}
예약어인 true 또는 fasle 두가지 값만 존재하며, 자바스크립트 값은 모두 불 값으로 변환될 수 있다.
{% endhint %}

> **falsy(false 같은 값), trusy(true 같은 값)**
>
> falsy와 trusy를 이용해 조건문을 작성할 수 있다. 다만 어떤 식으로 작성할지는 어떤 값이 할당된다고 예상하느냐에 따라 다르다.&#x20;

```
if(num !== null) num + 1   // null만 아니면 될 
if(num) console.log(num)   // trusy한 값일 때만 (0은 falsy한 값이므 실행 X)
```

## 🐇 Null and Undefined

{% hint style="info" %}
동등 연산자는 null과 undefined가 같다고 간주하며, 일치 연산자는 두 값을 구분한다. 둘 다 falsy한 값으로 취급되며, 유일하게 이 두가지 타입만 프로퍼티나 메서드가 없다.&#x20;
{% endhint %}

> **null**
>
> null은 의도적으로 값이 없음을 나타낼 때 사용하는 특별한 값이다. typeof 연산자를 사용하면 문자열 'object'를 반환한다.

> **undefined**
>
> undefined는 초기화되지 않는 값이며, 존재하지 않는 객체 프로퍼티나 배열 요소에 접근했을 때 반환되는 값이다. 또한 값을 명시적으로 반환하지 않는 함수의 반환값이며 전달되지 않은 인자의 값이기도 하다.

## 🐇 심벌 Symbol (ES6)

{% hint style="info" %}
심벌은 문자열이 아닌 프로퍼티 이름으로, 심벌 값을 가져올 때는 Symbol() 함수를 호출하며 이 함수는 같은 인자로 호출하더라도 절대 같은 값을 반환하지 않는다. 때문에 심벌인 프로퍼티 이름을 사용하고 그 심벌을 공유하지 않으면 프로그램의 다른 모듈에서 실수로 해당 프로퍼티를 덮어쓸 수 없다.
{% endhint %}

> **Symbol()과 Symbol.for()**
>
> Symbol()은 어떤 인자를 입력하든 언제나 고유한 새 값을 반환하는 반면, Symbol.for()은 인자로 입력한 문자열과 연관된 심벌이 존재하면 기존 심벌을 반환하고, 존재하지 않는 경우에만 새 심벌을 생성해 반환한다.

```js
const sym_1 = Symbol('apple')
const sym_2 = Symbol('apple')

const sym_3 = Symbol.for('banana')
const sym_4 = Symbol.for('banana')

symbol_1 === symbol_2   // false
symbol_3 === symbol_4   // true
```

> **Symbol.prototype.description**
>
> 심벌을 출력할 때는 description을 통해 문자열로 변환해주어 에러를 방지할 수 있다.

```js
symbol_1.description  // 'apple'
symbol_3.description  // 'banana'
```
