# Immutable-Primitive-Values

## 🐇 기본 타입 (불변)

{% hint style="info" %}
숫자, 문자열, 불, 심벌(ES6), null 과 undefined 만이 기본 타입이다.
{% endhint %}

* 기본 타입은 할당된 값 자체가 메모리에 저장되며, 입력한 값이 이미 메모리 주소에 있으면 새롭게 메모리를 만들지 않고 해당 메모리 주소만 지정해준다.
* 또한 기본 타입은 불변이므로 값을 바꿀 수 없다. 상식적으로 생각해도 숫자 2를 3으로 바꾸는 것을 불가능 하다. 문자의 경우 배열로 생각하여 바꿀 수 있다고 착각할 수 있는데, 인덱스트롤 통해 문자열의 특정 텍스트에 접근할 수는 있지만 기존 문자열을 바꿀 수는 없다.

## 🐇 숫자 Number

{% hint style="info" %}
자바스크립트 숫자 형식은 (-2 \*\* 53) \~ (2 \*\* **** 53) 사이의 정수 및 부동소수점 숫자를 표현한다.
{% endhint %}

> **정수 리터럴**
>
> 자바스크립트는 10진 정수 리터럴 뿐만 아니라 2진수(0b), 8진수(0o), 16진수(0x) 값도 인식한다.

```
0b10101  // 21: 2진수 
0o377    // 255 8진수
0xff     // 255: 16진수
```

> **부동 소수점 리터럴**
>
> 부동 소수점 리터럴에는 소수점이 포함될 수 있으며, 지수 표기법으로도 표현할 수 있다.

```
3.14
.333333
6.02e25
1.4E-32
```

> **숫자 리터럴의 구분자**
>
> 다음과 같이 리터럴 안에 밑줄을 이용해 읽기 쉽게 구분할 수 있다.

```
const billion = 1_000_000_000  // 천 단위 구분자
const bytes = 0x89_AB_CD_EF    // 바이트 구분자
const bits = 0b0001_1101_0111  // 4비트 구분
```

> **자바스크립트의 산술 연산**\
> ****더하기, 빼기, 나누기, 나버지, 지수와 같은 본 산술 연산자 외에도 자바스크립트는 Math 객체의 프로퍼티로 정의된 함수를 통해 복잡한 수학 계산을 지원한다.

```
1/0                    // Infinity
Number.MAX_VALUE * 2   // Infinity
-1/0                   // -Infinity
-Number.MAX_VALUE * 2  // -Infinity
0/0                    // NaN
Infinity/Infinity      // NaN
Number.Min_VALUE       // 0
-1/Infinity            // -0
```

{% hint style="info" %}
NaN 값은 자기 자신을 포함해 어던 값과도 같지 않다. 즉, 변수 x의 값이 NaN인지 알아보기 위해 x ===NaN를 사용할 수 없다. x != x 또는 Number.isNaN(x)를 사용해야 한다.
{% endhint %}

> **이진 부동 소수점 숫자와 반올림 오류**
>
> 자바스크립트를 비롯해 최신 프로그래밍 언어에서 사용하는 IEEE 754 부동 소수점 표현은 이진 표현이며 1/2, 1/8, 1/1024같은 분수는 정확히 표현할 수 있지만 0.1 같은 단순한 숫자는 정확하게 표현하지 못한다. 부동 소수점 근삿값 때문에 프로그램에 문제가 생기는 것을 해결하기 위해 정수로 변환하는 방법이 있다.

```
const x = 0.3-0.2  // 0.09999999999999998
const y = 0.2-0.1  // 0.1
x === y            // false
```

> **BigInt (ES 2020)**
>
> 64비트 정수를 표현하기 위해 새로 추가된 기능으로, 연속된 숫다 다음 소문자 n을 붙인 형식이다.\
> BigInt() 함수를 사용해 숫자나 문자열을 BigInt로 변환할 수 있으며, 일반적인 산술은 숫자와 유사하지만 나눗셈을 할 때 나머지를 버린다는 특징이 있다. 또한 BigInt 피연산자와 일반적인 숫자 피연산자를 섞어서 사용할 수 없다. 반면 비교 연산자는 피연산자를 섞어도 괜찮다.

```
1000n + 2000n // 3000n
2000n -1000n  // 1000n
2000n * 3000n //6000000n
3000n / 977n  // 3n
3000n % 977n  // 9n
```

## 🐇 문자열 String

{% hint style="info" %}
자바스크립트 문자열은 16비트 값이 순서에 따라 이어진 형태이며, 각 값은 일반적으로 유니코드 문자이다. 자바스크립트 문자열 메서드는 대부분 문자가 아니라 16비트 값 단위로 동작하며, 예로 문자열의 길이는 그 문자열에 포함된 16비트 값의 갯수이다.&#x20;
{% endhint %}

> **코드 포인트**
>
> 자바스크립트 문자열은 부호 없는 16비트 값의 연속이며, 널리 사용되는 유니코드 문자의 코드 포인트는 16비트 이내이므로 문자열 요소 하나로 표현할 수 있다. 코드 포인트가 16비트를 넘는 유니코드 문자는 16비트 두개를 연속으로 쓰는 UTF-16 규칙(써로게이트 페어)로 인코드 한다. 즉 길이자 2인(16비트 값 두 개인) 문자열이 유니코드 문자 하나를 나타내는 경우도 있다.

```
const heart = '💙'
heart.length // 2: UTF-16 인코딩 \ud83d\udc99
```

> **문자열 이스케이프 시퀀스**
>
> 자바스크립트 문자열세어 역슬래시는 문자열에 표시할 수 없는 문자를 표현하는 특별한 의미를 갖는다.

```
\n // 뉴라인
\t // 탭
\' 작은 따옴표
\" 큰 따옴표
\\ 역슬래시


























































































































































































































































































```

## 🐇 불 Boolean



## 🐇 Null and Undefined



## 🐇 심벌 Symbol



* map 이나 자료구조에서 고유한 식별자가 필요하거나, 동시에 다발적으로 일어날 수 있는 코드에서 우선순위를 주고 싶을 때 유용

```js
const symbol1 = Symbol('id')
const symbol2 = Symbol('id')
console.log(symbol1 === symbol2) // false
```

```js
const symbol1 = Symbol.for('id')
const symbol2 = Symbol.for('id')
console.log(symbol1 === symbol2) // true
```

* 출력할 때는 .descript을 통해 string으로 변환해야 에러 안뜸

```js
console.log(`${symbol1.description}, ${symbol2.description}`)
```
