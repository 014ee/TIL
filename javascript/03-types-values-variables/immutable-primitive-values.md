# Immutable-Primitive-Values

## 🐇 기본 타입 (불변)

{% hint style="info" %}
**숫자, 문자열, 불, 심벌(ES6), null 과 undefined** 만이 기본 타입이다.

기본 타입은 할당된 값 자체가 메모리에 저장되며, 입력한 값이 이미 메모리 주소에 있으면 새롭게 메모리를 만들지 않고 해당 메모리 주소만 지정해준다.

또한 기본 타입은 불변이므로 값을 바꿀 수 없다. 상식적으로 생각해도 숫자 2를 3으로 바꾸는 것을 불가능 하다. 메서드 또한 값을 수정하는 것이 아닌 새 문자열을 반환하는 것이다. 문자의 경우 배열로 생각하여 바꿀 수 있다고 착각할 수 있는데, 인덱스트롤 통해 문자열의 특정 텍스트에 접근할 수는 있지만 기존 문자열을 바꿀 수는 없다. (읽기 전용 배열로 취급)
{% endhint %}

## 🐇 숫자 Number

{% hint style="info" %}
자바스크립트 숫자 형식은 (-2 \*\* 53) \~ (2 \*\* **** 53) 사이의 정수 및 부동소수점 숫자를 표현한다.
{% endhint %}

> **정수 리터럴**
>
> 자바스크립트는 10진 정수 리터럴 뿐만 아니라 2진수(0b), 8진수(0o), 16진수(0x) 값도 인식한다.

```
0b10101  // 21: 2진수 
0o377    // 255 8진수
0xff     // 255: 16진수
```

> **부동 소수점 리터럴**
>
> 부동 소수점 리터럴에는 소수점이 포함될 수 있으며, 지수 표기법으로도 표현할 수 있다.

```
3.14
.333333
6.02e25
1.4E-32
```

> **숫자 리터럴의 구분자**
>
> 다음과 같이 리터럴 안에 밑줄을 이용해 읽기 쉽게 구분할 수 있다.

```
const billion = 1_000_000_000  // 천 단위 구분자
const bytes = 0x89_AB_CD_EF    // 바이트 구분자
const bits = 0b0001_1101_0111  // 4비트 구분
```

> **자바스크립트의 산술 연산**\
> ****더하기, 빼기, 나누기, 나버지, 지수와 같은 본 산술 연산자 외에도 자바스크립트는 Math 객체의 프로퍼티로 정의된 함수를 통해 복잡한 수학 계산을 지원한다.

```
1/0                    // Infinity
Number.MAX_VALUE * 2   // Infinity
-1/0                   // -Infinity
-Number.MAX_VALUE * 2  // -Infinity
0/0                    // NaN
Infinity/Infinity      // NaN
Number.Min_VALUE       // 0
-1/Infinity            // -0
```

{% hint style="info" %}
NaN 값은 자기 자신을 포함해 어던 값과도 같지 않다. 즉, 변수 x의 값이 NaN인지 알아보기 위해 x ===NaN를 사용할 수 없다. x != x 또는 Number.isNaN(x)를 사용해야 한다.
{% endhint %}

> **이진 부동 소수점 숫자와 반올림 오류**
>
> 자바스크립트를 비롯해 최신 프로그래밍 언어에서 사용하는 IEEE 754 부동 소수점 표현은 이진 표현이며 1/2, 1/8, 1/1024같은 분수는 정확히 표현할 수 있지만 0.1 같은 단순한 숫자는 정확하게 표현하지 못한다. 부동 소수점 근삿값 때문에 프로그램에 문제가 생기는 것을 해결하기 위해 정수로 변환하는 방법이 있다.

```
const x = 0.3-0.2  // 0.09999999999999998
const y = 0.2-0.1  // 0.1
x === y            // false
```

> **BigInt (ES 2020)**
>
> 64비트 정수를 표현하기 위해 새로 추가된 기능으로, 연속된 숫다 다음 소문자 n을 붙인 형식이다. BigInt() 함수를 사용해 숫자나 문자열을 BigInt로 변환할 수 있으며, 일반적인 산술은 숫자와 유사하지만 나눗셈을 할 때 나머지를 버린다는 특징이 있다. 또한 BigInt 피연산자와 일반적인 숫자 피연산자를 섞어서 사용할 수 없다. 반면 비교 연산자는 피연산자를 섞어도 괜찮다.

```
1000n + 2000n // 3000n
2000n -1000n  // 1000n
2000n * 3000n //6000000n
3000n / 977n  // 3n
3000n % 977n  // 9n
```

## 🐇 문자열 String

{% hint style="info" %}
자바스크립트 문자열은 16비트 값이 순서에 따라 이어진 형태이며, 각 값은 일반적으로 유니코드 문자이다. 자바스크립트 문자열 메서드는 대부분 문자가 아니라 16비트 값 단위로 동작하며, 예로 문자열의 길이는 그 문자열에 포함된 16비트 값의 갯수이다.&#x20;
{% endhint %}

> **코드 포인트**
>
> 자바스크립트 문자열은 부호 없는 16비트 값의 연속이며, 널리 사용되는 유니코드 문자의 코드 포인트는 16비트 이내이므로 문자열 요소 하나로 표현할 수 있다. 코드 포인트가 16비트를 넘는 유니코드 문자는 16비트 두개를 연속으로 쓰는 UTF-16 규칙(써로게이트 페어)로 인코드 한다. 즉 길이자 2인(16비트 값 두 개인) 문자열이 유니코드 문자 하나를 나타내는 경우도 있다.

```
const heart = '💙'
heart.length // 2: UTF-16 인코딩 \ud83d\udc99
```

> **문자열 이스케이프 시퀀스**
>
> 자바스크립트 문자열에 역슬래시는 문자열에 표시할 수 없는 문자를 표현하는 특별한 의미를 갖는다.

```
\n      // 뉴라인
\t      // 탭
\'      // 작은 따옴표
\"      // 큰 따옴표
\\      // 역슬래시
\xnn    // 16진수 숫자 두개로 표현하는 유니코드 문
\unnnn  // 16진수 숫자 4개로 표현하는 유니코드 문자
\u{n}   // 코드포인트 n으로 표현하는 유니코드 문자 
```

> **태그된 탬플릿 리터럴**
>
> 백틱 바로 앞에 함수 이름이 있으면 템플릿 리터럴의 텍스트와 표현식 값이 함수에 전달되며, 이후 태그된 템플릿 리터럴 값이 함수의 반환이 된다.&#x20;

```
`\n`.length            // 1
String.raw`\n`.length  // 2: String.raw는 이스케이프를 처리하지 않고 문자 그대로 반환 
```

## 🐇 불 Boolean

{% hint style="info" %}
예약어인 true 또는 fasle 두가지 값만 존재하며, 자바스크립트 값은 모두 불 값으로 변환될 수 있다.
{% endhint %}

> **falsy(false 같은 값), trusy(true 같은 값)**
>
> 참인 것 같은 값, 거짓인 것 같은 값을 이용해 조건문을 작성할 수 있다. 다만 아래와 같이 여러 방식으로 작성할 수 있는데, 어느 if 문이 적절한지는 프로그램에서 어떤 값이 할당된다고 예상하느냐에 따라 다르다.&#x20;

```
if(num !== null) num + 1   // null과 다른 falsy한 값을 구분해야 할, 0 입력시 실행 가
if(num) console.log(num)   // falsy한 값만 아니면 될, 0 입력시 실행 불가
```

## 🐇 Null and Undefined

{% hint style="info" %}
동등 연산자는 null과 undefined가 같다고 간주하며, 일치 연산자는 두 값을 구분한다.\
둘 다 falsy한 값으로 취급되며, 유일하게 이 두가지 타입만 프로퍼티나 메서드가 없다.&#x20;
{% endhint %}

> **null**
>
> null은 의도적으 값이 없음을 나타낼 때 사용하는 특별한 값이다.\
> typeof 연산자를 사용하면 문자열 'object'를 반환한다.

> **undefined**
>
> undefined는 초기화되지 않는 값이며, 존재하지 않는 객체 프로퍼티나 배열 요소에 접근했을 때 반환되는 값이다. 또한 값을 명시적으로 반환하지 않는 함수의 반환값이며 전달되지 않은 인자의 값이기도 하다.

## 🐇 심벌 Symbol (ES6)

{% hint style="info" %}
심벌은 문자열이 아닌 프로퍼티 이름으로, 심벌 값을 가져올 때는 Symbol() 함수를 호출하며 이 함수는 같은 인자로 호출하더라도 절대 같은 값을 반환하지 않는다. 때문에 심벌인 프로퍼티 이름을 사용하고 그 심벌을 공유하지 않으면 프로그램의 다른 모듈에서 실수로 해당 프로퍼티를 덮어쓸 수 없다.
{% endhint %}

> **Symbol()과 Symbol.for()**
>
> Symbol()은 어떤 인자를 입력하든 언제나 고유한 새 값을 반환하는 반면, Symbol.for()은 인자로 입력한 문자열과 연관된 심벌이 존재하면 기존 심벌을 반환하고, 존재하지 않는 경우에만 새 심벌을 생성해 반환한다.

```js
const sym_1 = Symbol('apple')
const sym_2 = Symbol('apple')

const sym_3 = Symbol.for('banana')
const sym_4 = Symbol.for('banana')

symbol_1 === symbol_2   // false
symbol_3 === symbol_4   // true
```

> **Symbol.prototype.description**
>
> 심볼을 출력할 때는 description을 통해 string으로 변환함으로 에러를 방지할 수 있다.

```js
symbol_1.description  // 'apple'
symbol_3.description  // 'banana'
```
