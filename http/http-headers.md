# HTTP Headers

## 개요

* HTTP 전송에 필요한 모든 부가정보\
  EX. 메세지 바디의 내용, 바디의 크기, 압축, 인증, 요청 클라이언트, 서버 정보, 캐시 관리&#x20;

#### 현재 HTTP 표준: 2014년 RFC7230\~7235

* 메세지 바디를 통해 표현 데이터 전달
* 페이로드(payload): 메세지 본문 (= 표현 데이터)
* 표현: 요청이나 응답에서 전달할 실제 데이터 (표현 헤더 + 표현 데이터)
* 표현 헤더: 표현 데이터를 해석할 수 있는 정보 제공 (데이터 유형, 길이, 압축 정보 )

## 표현 헤더

* Content-Type: 표현 데이터의 형식 (ex. text/html; charset=utf-8, application/json, image/png)
* Content-Encoding: 표현 데이터의 압축 방식 (압축된 데이터의 압축 해제 방식/gzip, identity )
* Content-Language: 표현 데이터의 자연 언어 (ko, en, en-US )
* Content-Length: 표현 데이터의 바이트 단위의 길이 (Transfer-Encoding을 사용할 경우 사용 불)



## 컨텐츠 협상

클라이언트가 선호하는 표현을 요청하는 것으로 http 요청시에만 사용하며 서버에서 해당 못줄수도 있다.

* Accept: 클라이언트가 선호하는 미디어 타입
* Accept-Charset: 클라이언트가 선호하는 문자 인코딩
* Accept-Encoding: 클라이언트가 선호하는 압축 인코딩
* Accept-Language: 클라이언트가 선호하는 자연 언어 (ex. 다중 언어 지원 서버 등에서 사용 가)

협 상과 우선순

* 0\~1로 우선순위를 지정할 수 있으며 생략하면 1이다.\
  (ex. Accept-Language: ko-KR, ko;q=0.9,en-US;Q=0.8;EN;Q=0.7)



## 전송 방식

* 단순 전송 (Content-Length 값을 알고 있을 때 사용 가능하다)
* 압축 전송 (데이터를 압축 후에 전송하는 방식, 뭘로 압축했는지 Content-Encoding에 담아서 응답해야한다.)
* 분할 전송 (청크로 쪼개서 전송하는 방식으로 용량이 너무 커서 한번에 보내면 시간이 걸릴 경우 주로 사용한다. 길이를 모르므로 Content-Length를 보내면 안됨 )
* 범위 전송 (데이터를 받다가 중간에 끊긴 경우 나머지를 다시 요청하는 경우에 사용할 수 있)



## 일반 정보

* From: 유저 에이전트의 이메일 정보
* Referer: 이전 웹페이지 정보 (유입 경로를 분석하는데 사용 가)
* User-Agent: 유저 에이전트 애플리케이션 정보 (특정 브라우저에서 버그가 생길 경우 서버에서 로그를 파싱해서 파악하는데 도움을 준다.)
* Server: 요청을 처리하는 오리진 서버의 소프트웨어 정보 (최종적으로 요청을 처리하는 ORIGIN 서버의 소프트웨어 정보)
* Date: 메시지가 생성된 날짜와 시간



## 특별한 정보

* Host: 요청한 호스트 정보(도메인), 하나의 서버(IP)가 여러 어플리케이션이 적용되어 있을 때(즉 가상 호스트를 통해 하나의 서버에 여러 도메인이  존재할 ) 어느 도메인에 요청한건지 명시
* Location: 페이지 리다이렉션 (3xx 응답 결과에 location 헤더가 있으면 해당 위치로 자동 이), 201 응답 결과(Created)시에도 존재)
* Allow: 허용하지 않는 메서드로 HTTP 요청했을 때, 서버에서 405(Method Not Allowed) 상태코드와 함께 허용 가능한 HTTP 메서드를 전달해줄 수 있다. (ex. Allow: GET, HEAD, PUT)
* Retry-After: 유저 에이전트가 다음 요청을 하기까지 기다려야하는 시간 (날짜 또는 초단위로 표기 가)\
  503(Service Unavailable): 서비스가 언제까지 이용 불가능한지 알려주는 상태코드\
  Retry-After: Fri, 31 Dec 1999 23:59:59 GMT (날짜 표기)\
  Retry-Afger: 120 (초단 표기)&#x20;



## 인증

* Authorization: 클라이언트의 인증 정보를 서버에 전달 (인증에는 여러 매커니즘이 있는데, 그 매커니즘마다 값이 달라진다.)
* www-Authenticate: 리소스 접근시 필요한 인증 방법 정의, 인증 정보가 잘못되었을 때 401(Unauthorized) 상태코드와 함께 www-Authenticate  정보를 참고해서 제대로된 인증 정보를 만들라고 응답한다.&#x20;



## 쿠키

HTTP는 무상태 프로토콜로, 요청과 응답을 주고 받으면 연결이 끊기므로 사용자가 로그인 등을 했을 때 로그인 상태를 유지하지 않는다. 이를 해결하기 위해 요청 모든 정보를 포함해서 요청할 수 있는데, 이 경우 개발 신경써야 할 부분이 많아지고 보안에도 취악해질 수 있다. 이를 해결하기 위해 생긴게 쿠키이다.\
\=> 로그인 요청을 하면 서버에서 Set-Cookie에 로그인 정보 값을 담아서 응답\
\=> 웹 브라우저 내부에 쿠키 저장소가 있는데, 이 값을 저장해\
\=> 이후 클라이언트에서 서버에 요청을 보낼 때마다 항상 브라우저의 쿠키 저장소를 먼저 확인하고, 쿠키 내 정보를 담아서 요청을 보냄

\
이 역시 모든 쿠키를 그대로 보내면 보안과 관련된 문제가 발생하므로 아래와 같이 사용됨

* 로그인이 성공되면 세션키라는 것을 만들어서 서버의 데이터베이스에 저장해놓고, Set-cookie에 쿠키 정보로 세팅해서 응답\
  Set-Cookie: sessionId=abcde1234; expires=Sat, 26-Dec-2020 00:00:00 GMT; path=/; domain=.google.com;Secure\
  \- 사용자 로그인 세션관리, 광고 정보 트래킹 등에서 사용\
  \- 따라서 쿠키 정보는 항상 서버에 전송되므로 네트워크 트래픽이 추가로 유발되고, 최소한의 정보만 사용하는 것이 좋다. (세션 ID, 인증 토큰 정도) // 데이터를 서버가 아닌 웹 브라우저 내부에 저장하고 사용하고 싶으면 웹 스토리지 사용하면 된다. 단 주민번호, 신용카드 번호와 같이 보안에 민감한 데이터는 저장하면 안됨  \

* Set-Cookie: 서버에서 클라이언트로 쿠키 전
* Cookie: 클라이언트가 서버에서 받은 쿠키를 저장하고, HTTP 요청시 서버로 전달



#### 쿠키 생명주기

* expires: Sat, 26-Dec-2020 00:00:00 GMT; (쿠키 저장 만료일로 만료일이 되면 자동 삭제)
* max-age: 3600 (초단위 만료일로, 0이나 음수를 지정하면 삭제)&#x20;
* 세션 쿠키: 만료 날짜를 생략하면 브라우저 종료까지만 유지
* 영속 쿠키: 만료 날짜를 입력하면 해당 날짜까지 유

#### 쿠키 도메인

* domain=naver.com;
* 명시: 명시한 도메인 + 서브 도메인 포함 쿠키를 접근할 수 있음 (ex. naver.com, m.naver.com)
* 생략: 도메인 지정을 생략할 경우, 쿠키를 생성한 도메인에서만 접근 가능하고 서브 도메인에서는 접근할 수 없다.&#x20;

#### 쿠키 경로

* path=/ (지정한 경로를 포함한 하위 경로 페이지만 쿠키 접근하다. 일반적으로 도메인 내에서 전반적으로 활용하기 때문에 루트로 지정한다. )

#### 쿠키 보안

* Secure: 기본적으로 쿠키는 http, https를 구분하지 않고 전송하는데, Secure을 적용하여 https인 경우에만 전송하도록 할 수 있다.
* HttpOnly: XSS 공격을 방지하기 위한 것으로 자바스크립트에서 접근 불가(document.cookie)하고 HTTP 전송에만 사용 가능하게 해준다.
* SameSite: XSRF 공격 방지하기 위한 것으로, 요청하 도메인과 쿠키에 설정된 도메인이 같은 경우만 쿠키를 전송할 수 있게 한다.&#x20;



## 캐시







## 검증 헤더와 조건부 요청



## 캐시와 조건부 요청 헤더





## 프록시 캐시



## 캐시 무효

