# HTTP Headers

## 개요

* HTTP 전송에 필요한 모든 부가정보\
  EX. 메세지 바디의 내용, 바디의 크기, 압축, 인증, 요청 클라이언트, 서버 정보, 캐시 관리&#x20;

#### 현재 HTTP 표준: 2014년 RFC7230\~7235

* 메세지 바디를 통해 표현 데이터 전달
* 페이로드(payload): 메세지 본문 (= 표현 데이터)
* 표현: 요청이나 응답에서 전달할 실제 데이터 (표현 헤더 + 표현 데이터)
* 표현 헤더: 표현 데이터를 해석할 수 있는 정보 제공 (데이터 유형, 길이, 압축 정보 )

## 표현 헤더

* Content-Type: 표현 데이터의 형식 (ex. text/html; charset=utf-8, application/json, image/png)
* Content-Encoding: 표현 데이터의 압축 방식 (압축된 데이터의 압축 해제 방식/gzip, identity )
* Content-Language: 표현 데이터의 자연 언어 (ko, en, en-US )
* Content-Length: 표현 데이터의 바이트 단위의 길이 (Transfer-Encoding을 사용할 경우 사용 불)



## 컨텐츠 협상

클라이언트가 선호하는 표현을 요청하는 것으로 http 요청시에만 사용하며 서버에서 해당 못줄수도 있다.

* Accept: 클라이언트가 선호하는 미디어 타입
* Accept-Charset: 클라이언트가 선호하는 문자 인코딩
* Accept-Encoding: 클라이언트가 선호하는 압축 인코딩
* Accept-Language: 클라이언트가 선호하는 자연 언어 (ex. 다중 언어 지원 서버 등에서 사용 가)

협 상과 우선순

* 0\~1로 우선순위를 지정할 수 있으며 생략하면 1이다.\
  (ex. Accept-Language: ko-KR, ko;q=0.9,en-US;Q=0.8;EN;Q=0.7)



## 전송 방식

* 단순 전송 (Content-Length 값을 알고 있을 때 사용 가능하다)
* 압축 전송 (데이터를 압축 후에 전송하는 방식, 뭘로 압축했는지 Content-Encoding에 담아서 응답해야한다.)
* 분할 전송 (청크로 쪼개서 전송하는 방식으로 용량이 너무 커서 한번에 보내면 시간이 걸릴 경우 주로 사용한다. 길이를 모르므로 Content-Length를 보내면 안됨 )
* 범위 전송 (데이터를 받다가 중간에 끊긴 경우 나머지를 다시 요청하는 경우에 사용할 수 있)



## 일반 정보

* From: 유저 에이전트의 이메일 정보
* Referer: 이전 웹페이지 정보 (유입 경로를 분석하는데 사용 가)
* User-Agent: 유저 에이전트 애플리케이션 정보 (특정 브라우저에서 버그가 생길 경우 서버에서 로그를 파싱해서 파악하는데 도움을 준다.)
* Server: 요청을 처리하는 오리진 서버의 소프트웨어 정보 (최종적으로 요청을 처리하는 ORIGIN 서버의 소프트웨어 정보)
* Date: 메시지가 생성된 날짜와 시간



## 특별한 정보

* Host: 요청한 호스트 정보(도메인), 하나의 서버(IP)가 여러 어플리케이션이 적용되어 있을 때(즉 가상 호스트를 통해 하나의 서버에 여러 도메인이  존재할 ) 어느 도메인에 요청한건지 명시
* Location: 페이지 리다이렉션 (3xx 응답 결과에 location 헤더가 있으면 해당 위치로 자동 이), 201 응답 결과(Created)시에도 존재)
* Allow: 허용하지 않는 메서드로 HTTP 요청했을 때, 서버에서 405(Method Not Allowed) 상태코드와 함께 허용 가능한 HTTP 메서드를 전달해줄 수 있다. (ex. Allow: GET, HEAD, PUT)
* Retry-After: 유저 에이전트가 다음 요청을 하기까지 기다려야하는 시간 (날짜 또는 초단위로 표기 가)\
  503(Service Unavailable): 서비스가 언제까지 이용 불가능한지 알려주는 상태코드\
  Retry-After: Fri, 31 Dec 1999 23:59:59 GMT (날짜 표기)\
  Retry-Afger: 120 (초단 표기)&#x20;



## 인증

* Authorization: 클라이언트의 인증 정보를 서버에 전달 (인증에는 여러 매커니즘이 있는데, 그 매커니즘마다 값이 달라진다.)
* www-Authenticate: 리소스 접근시 필요한 인증 방법 정의, 인증 정보가 잘못되었을 때 401(Unauthorized) 상태코드와 함께 www-Authenticate  정보를 참고해서 제대로된 인증 정보를 만들라고 응답한다.&#x20;



## 쿠키

HTTP는 무상태 프로토콜로, 요청과 응답을 주고 받으면 연결이 끊기므로 사용자가 로그인 등을 했을 때 로그인 상태를 유지하지 않는다. 이를 해결하기 위해 요청 모든 정보를 포함해서 요청할 수 있는데, 이 경우 개발 신경써야 할 부분이 많아지고 보안에도 취악해질 수 있다. 이를 해결하기 위해 생긴게 쿠키이다.\
\=> 로그인 요청을 하면 서버에서 Set-Cookie에 로그인 정보 값을 담아서 응답\
\=> 웹 브라우저 내부에 쿠키 저장소가 있는데, 이 값을 저장해\
\=> 이후 클라이언트에서 서버에 요청을 보낼 때마다 항상 브라우저의 쿠키 저장소를 먼저 확인하고, 쿠키 내 정보를 담아서 요청을 보냄

\
이 역시 모든 쿠키를 그대로 보내면 보안과 관련된 문제가 발생하므로 아래와 같이 사용됨

* 로그인이 성공되면 세션키라는 것을 만들어서 서버의 데이터베이스에 저장해놓고, Set-cookie에 쿠키 정보로 세팅해서 응답\
  Set-Cookie: sessionId=abcde1234; expires=Sat, 26-Dec-2020 00:00:00 GMT; path=/; domain=.google.com;Secure\
  \- 사용자 로그인 세션관리, 광고 정보 트래킹 등에서 사용\
  \- 따라서 쿠키 정보는 항상 서버에 전송되므로 네트워크 트래픽이 추가로 유발되고, 최소한의 정보만 사용하는 것이 좋다. (세션 ID, 인증 토큰 정도) // 데이터를 서버가 아닌 웹 브라우저 내부에 저장하고 사용하고 싶으면 웹 스토리지 사용하면 된다. 단 주민번호, 신용카드 번호와 같이 보안에 민감한 데이터는 저장하면 안됨  \

* Set-Cookie: 서버에서 클라이언트로 쿠키 전
* Cookie: 클라이언트가 서버에서 받은 쿠키를 저장하고, HTTP 요청시 서버로 전달



#### 쿠키 생명주기

* expires: Sat, 26-Dec-2020 00:00:00 GMT; (쿠키 저장 만료일로 만료일이 되면 자동 삭제)
* max-age: 3600 (초단위 만료일로, 0이나 음수를 지정하면 삭제)&#x20;
* 세션 쿠키: 만료 날짜를 생략하면 브라우저 종료까지만 유지
* 영속 쿠키: 만료 날짜를 입력하면 해당 날짜까지 유

#### 쿠키 도메인

* domain=naver.com;
* 명시: 명시한 도메인 + 서브 도메인 포함 쿠키를 접근할 수 있음 (ex. naver.com, m.naver.com)
* 생략: 도메인 지정을 생략할 경우, 쿠키를 생성한 도메인에서만 접근 가능하고 서브 도메인에서는 접근할 수 없다.&#x20;

#### 쿠키 경로

* path=/ (지정한 경로를 포함한 하위 경로 페이지만 쿠키 접근하다. 일반적으로 도메인 내에서 전반적으로 활용하기 때문에 루트로 지정한다. )

#### 쿠키 보안

* Secure: 기본적으로 쿠키는 http, https를 구분하지 않고 전송하는데, Secure을 적용하여 https인 경우에만 전송하도록 할 수 있다.
* HttpOnly: XSS 공격을 방지하기 위한 것으로 자바스크립트에서 접근 불가(document.cookie)하고 HTTP 전송에만 사용 가능하게 해준다.
* SameSite: XSRF 공격 방지하기 위한 것으로, 요청하 도메인과 쿠키에 설정된 도메인이 같은 경우만 쿠키를 전송할 수 있게 한다.&#x20;



## 캐시

#### &#x20;캐시가 없을 때

* 데이터가 변경되지 않아도 요청할 때 마다 계속 네트워크를 통해 다운받는다.
* 인터넷 넷트워크는 매우 느리고 비싸다.
* 브라우저 로딩 속도가 느리므로 느린 사용자 경험을 제공한다.

#### 캐시가 있으면

* 캐시 유효 시간동안 네트워크를 사용하지 않아도 되므로 비싼 네트워크 사용량을 줄일 수 있다.
* 브라우저 로딩 속도가 매우 빨라지므로 빠른 사용자 경험을 제공한다.

#### 캐시 기본 동=>&#x20;

* 첫번째 응답시 헤더에 cache-control (캐시가 유효한 시간)을 담아서 데이터를 보내준다.
* 웹 브라우저는 응답 결과를 브라우저 캐시에 저장한다.
* 두번째 요청시 캐시를 먼저 보고, 캐시에 데이터가 있으면 그 데이터를 사용한다. 캐시가 없거나 유효시간이 초과되었으면 네트워크 요청을 하고 기존 캐시 값을 갱신한다. (=> 클라이언트에서 이전에 다운받아 캐시로 저장된 데이터와 현재 서버의 데이터가 동일하다면 캐시 유효시간이 지났다고 다시 똑같은 데이터를 다운받는 것은 비효율적 => 그래서 생긴게 검증 헤더와 조건부 요)



## 검증 헤더와 조건부 요청

#### 서버에서 기존 데이터 변경된 경우



#### 서버에서 기존 데이터를 변경하지 않은 경우

#### 검증헤더

#### Last-Modified, ETag

* 캐시 데이터와 서버 데이터가 같은지 검증하는 데이
* 클라이언트의 데이터와 서버의 데이터가 같다는 검증 필요
* 첫번째 응답에서 헤더에 Last-Modified를 입력해 데이터가 마지막으로 수정된 날짜를 전달
* 두번째 요청시 캐시 유효 기간이 만료될 경우, 캐시에서 Last-Modified를 찾아 요청에 담아 보냄
* 요청시 담아 보낸 마지막 수정일과 서버의 데이터 마지막 수정일이 동일한지 체크
* 데이터가 수정이 안되었으면 304 Not Modified 상태코드와 함께 유효기간 등이 담긴 헤더만 다시 보냄 (바디는 안보냄) => 전부 다시 보내는 것에 비해 네트워크 부하가 줄어듬 => 클라이언트는 캐시 유효기간 다시 세팅 후 해당 데이터 불러와서 사

#### 조건부요청 헤더&#x20;

#### if-Match, if-None-Match: ETag 값 사용

if-Modified-Since, if-Unmodified-Since: Last-Modified 값 사

* 검증 헤더로 조건에 따른 분기
* if-modified-since: Last-Modified 사용
* if-None-Match: ETag 사용
* 조건을 만족하면 200 OK
* 조건을 만족하지 않으면 304 Not Modified
* 데이터 요청시 헤더에 캐시가 가지고 있는 데이터 최종 수정일( if-modified-since: 수정된 날짜 )를 담아서 보낸 후 지정된 날짜 이후 바뀐 데이터가 있는지 체크, 있으면 200 OK 상태코드와 함께 모든 데이터 전송 후 캐시 갱신, 없으면 304 Not Modified와 헤더 데이터만 전송 후 캐시 유효기간 갱

#### Last-Modifed, if-Modified-since 단점

* 1초 미만 단위로 캐시 조정 불가능
* 날짜 기반의 정해 로직 사용
* 같은 날짜에 데이터를 수정했다가 다시 복구한 경우에도 데이터가 수정됐다고 인식
* 따라서 서버에서 별도의 캐시 로직을 관리하고 싶은 경우가 있을 수 있음 (ex. 주석이 변경된 경우 정도에는 데이터가 변경되었다고 인식되지 않게 하고 싶음, 캐시를 유지하고 싶은 경우)\
  \=> 이처 서버에서 캐시 메커니즘을 컨트롤 하고 싶을 때 ETag(Entity Tag)를 사용한다.

#### ETag, if-none-match

* 단순히 ETag만 서버에 보내서 같으면 유지, 다르면 다시 받
* 캐시용 데이터에 임의의 고유한 이름을 달 수 있음 (버전이나 해시-파일 컨텐츠가 같으면 똑같은 해시 만들어줌)
* ETag: 'v1.0' or 'a2jiodwjekjil3'
* 데이터가 변경되면 이 이름을 변
* ETag만 보내서 같으면 유지, 다르면 다시 받
* 두번째 요청시 캐시 내 Etag의 값을 요청 헤더의 if-none-match에 담아 서버에 전달
* 매치가 되면 304 Not Modifed (데이터 안바뀜), 유효기간만 갱신
* 즉, 캐시 제어 로직을 서버에서 완전히 관리 (클라이언트는 매커니즘 몰라도 되고 단순히 이 값을 서버에 제공하기만 하면 됨) ex. 애플리케이션 배포 주기에 맞추어 ETag 모두 갱신 등에 사



## 캐시와 조건부 요청 헤더

&#x20;캐시 제어 헤더

1. Cache-Control: (캐시 제어)

* Cache-Control: max-age (캐시 유효기간)
* Cache-Control: no-cache (데이터는 캐시해도 되지만 항상 조건부 요청을 해서 origin 서버에 검증하고 사용)
* Cache-Control: no-store (데이터에 민감한 정보가 있으므로 저장하면 안됨/메모리에서 사용하고 최대한 빨리 삭)

1. Pragma: no-cache (HTTP 1.0 하위호환 캐시 제어)
2. Expires: Mon, 01 Jan 1990 00:00:00 GMT (HTTP 1.0 부터 사용)\
   지금은 더 유연한 Cache-Control: max-age 권



## 프록시 캐시

클라이언트와 서버의 거리가 먼 경우 그만큼 응답하는데 시간이 걸리기 때문에 이를 해결하기 위해 중간에 프록시 캐시 서버를 추가할 수 있다. (ex. 유튜브 같은 경우 한국 어딘가에 유튜브 프록시 서버에 사람들이 자주 보는 동영상들이 다운받아져 있기 때문에 빨리 다운받아서 볼 수 있는것, 사람들이 잘 안보는 영상을 첫번째로 시청하게 되면 새로 다운로드 받아야 하므로 시간이 걸린다. 또는 원 서버에서 프록시 캐시 서버로 데이터를 임의로 추가하는 방식도 있다.)



프록시 캐시 서버의 캐시는 public 캐시, 개인 pc의 웹 브라우저에 있는 캐시는 private 캐시라고 부른다.



캐 시 컨트롤

* Cache-Control: public (응답이 public 캐시에 저장되어도 됨)
* Cache-Control: private (응답이 해당 사용자만을 위한 것이므로 privat 캐시에 저장해야 함-기본값)
* Cache-Control: s-maxage (프록시 캐시에만 적용되는 max-age)
* Age: 60 (오리진 서버에서 응답 후 프록시 캐시 내에 머문 시간)



## 캐시 무효화

캐시 적용을 안해도 get 요청을 하면 브라우저에서 임의로 캐시하기도 함\
따라서 캐시를 절대 하면 안되거나 하는 경우 따로 아래 설정을 추가해야 한다.

* Cache-Control: no-cache, no-store, must-revalidate
* pragma: no-cache (http 1.0 하위 호)



* no-cache: 데이터는 캐시해도 되지만 항상 원 서버에 검증하고 사용
* no-store: 데이터에 민감한 정보가 있으므로 저장하면 안됨 (메모리에서 사용하고 최대한 빨리 삭제)
* must-revalidate: 캐시 만료 후 최초 조회시 원 서버에 검증해야함, 원 서버 접근 실패시 반드시 오류 발생 (504 Gateway Timeout), 캐시 유효 시간이라면 캐시를 사용함

&#x20;프록시 서버가 원 서버에 캐시 검증 요청 하는 순간 네트워크 단절이 일어나 원 서버에 접근 불가능할 경우, no-cache는 에러 대신 오래된 데이터라도 검증 없이 보여주는 설정을 할 수 있\
반면 must-revalidate는 원 서버에 접근할 수 없는 경우 항상 오류가 발생하게  됨(503 Gateway Timeout) => 돈을 이체하는 등의 상황에서는 예전 데이터를 불러오는 방식이 매우 위험하므로 must-revalidate 도 사용하는&#x20;





