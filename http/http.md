# HTTP

## HTTP (Hyper Text Transfer Protocol)

{% hint style="info" %}
초기에는 하이퍼 텍스트(html)를 위한 프로토콜로 개발되었는데, 현재는 이미지, 음성, 영상, JSON, XML 등 거의 모든 형태의 데이터를 주고 받는데 사용된다. (심지어 서버간에 데이터를 주고 받을 때도 HTTP를 사용한다. 참고로 HTTP 방식 말고 Socket 방식으로 HTTP 메세지 없이 TCP/IP에서 직접 3 handshake 후 데이터 전송할 수도 있다.)

http => 비동기적 프로토 (동기적 프로토콜로는 websocket이 있다.)
{% endhint %}

## HTTP 버전

* HTTP/0.9 : GET 메서드만 지원, HTTP 헤더 X (1991년)&#x20;
* HTTP/1.0 : 메서드, 헤더 추가 (1996년)
* HTTP/1.1 : 가장 많이 사용되고 있는 버전 (1997년)&#x20;
* HTTP/2.0 : 성능 개선 (2015년)&#x20;
* HTTP/3.0 : TCP 대신에 UDP 사용, 성능 개선 (현재)

## HTTP 특징

### 클라이언트-서버 구조

* 이전에는 클라이언트와 서버의 구조가 분리되어 있지 않고 하나로 있었다.
* 현재는 클라이언트와 서버의 구조가 분리되어 각 기능에 최적화된 상태로 독립적으로 진화할 수 있게 되었다. (클라이언트:  UI를 어떻게 그릴지 / 서버: 비지니스 로직, 데이터, 트래픽, 아키텍)
* 클라이언트는 요청을 보내고, 서버는 요청에 대한 결과를 만들어 응답을 한다.

### 무상태 프로토콜 (stateless)

* 서버가 클라이언트의 상태를 보존하지 않는다. (이전에 무슨 작업을 했는지 맥락을 알 수 없으므로 이전 작업에 의존적이지 않음) ex. 중간에 상담사가 바뀌어도 된다. (애초에 요청할 때 필요한 데이터를 다 담아서 요청하기 때문에 각 요청이 독립적) / 상태유지는 상태를 유지하고 있는 서버에 의존적이게&#x20;
* 갑자기 클라이언트 요청이 증가해도 서버를 대거 투입할 수 있다.
* 무상태는 응답하는 서버를 쉽게 바꿀 수 있다. => 무한 서버 증설 가 (스케일 아웃, 수평 확장 유)
* 서버가 중간에 죽어도 처음부터 다시 요청하지 않아도 되고, 서버 하나가 죽으면 다른 서버에 요청하면 된다.&#x20;
* 한계: 무상태로 설계할 수 있는 경우도 있고 없는 경우도 있다. 그러나 상태유지는 최소한으로 사용하는 것이 좋다. (로그인을 해야 서비스를 이용할 수 있는 경우 상태를 유지해야한다. 보통 이는 브라우저 쿠키와 서버의 세션을 사용해서 저장하며 유지하는데 비용이 들고 세션을 유지하는 부분을 확장하기 까다롭다.)
* 한번에 전달되는 데이터의 양이 많다.
* 즉 세션, 쿠키는 무상태인 특성을 가진 http를 가지고 사용자를 식별하거나 하기 위해 상태를 유지해야하는 상황을 위해 생겨난 기술라고 보면 됨 ( 로그인을 유지하기 위해 상태 유지를 하는 세션 외에도 상태유지 없이 로그인을 유지할 수 있도 JWT, oauth 등을 사용할 수도 있는데 각각의 장단점이 있기 때문에 특정 기술이 우우위에 있거나 하지는 않)
* 필요한 상태에 대한 정보를 클라이언트가 가지고 오기 때문에 클라이언트의 요청에 어느 서버가 응답해도 상관 없음. 따라서 클라이언트의 요청이 대폭 증가하면 서버를 증설해 해결할 수 있음

### 비연결성

* HTTP는 기본적으로 요청과 응답을 받고 나면 연결을 끊고, 요청이 필요할 때마다 연결을 하는 비연결성 특징을 갖는다.
* 일반적으로 초 단위 이하의 빠른 속도로 응답한다.
* 따라서 동시에 수천명이 서비스를 사용해도 실제 서버에서 동시에 처리하는 요청은 수 십개 이하로 매우 작다.
* 따라서 서버 자원을 매우 효율적으로 관리하고 수 많은 클라이언트의 요청에 대응할 수 있게 함
* TCP/IP 연결로 요청 후 응답을 하면 연결을 즉시 끊는다.

단점

* 뭔가 요청을 할 때마다 TCP/IP 연결을 새로 맺어야 하므로 3 way handshake 시간이 추가된다.
* &#x20;보통 웹 사이트는 html 하나의 파일만이 아니라 자바스크립트, css파일, 이미지 등의 여러 자원을 함께 불러와야 하므로 각 요청해야 하는 한계를 개선하기 위해 지금은 HTTP 지속 연결을 사용하고 HTTP 2와 3 버전에서 더욱 최적화가 진행 (일반적으로 60초 정도를 유지하고, 서버쪽에서 해당 설정을 할 수 있습니다) 즉, 기본은 비연결성이 맞는데 성능 최적화를 위해 약간의 연결 유지 기능이 추가된 방



CF) 서버에 클라이언트가 접속하면 서버 입장에서는 Request객체도 생성하고 Response 객체도 생성하는 등 내부적으로 많은 일을 합니다. 그리고 그런 동작에는 메모리와 CPU 등의 자원(리소스)이 소모됩니다. 그리고 이런 자원 사용을 최소화 하지 않으면 클라이언트가 몰렸을 때 부하가 일어납니다. 그래서 무상태 프로토콜을 구현함으로 써 이런 자원 사용을 최소화 한다는 의미입니다.

![](<../.gitbook/assets/image (1).png>)

![](<../.gitbook/assets/image (10).png>)

### HTTP 메세지를 통해 통신한다.

![](<../.gitbook/assets/image (3).png>)

#### 1. 시작라인 : request-line(요청 메세) / status line (응답 메세지)

request-line(요청 메세)

* request-line = HTTP 메서드 + 요청 대상 + HTTP Version\
  GET /serch?q=hello\&hl=ko HTTP/1.1
* HTTP 메서드 (GET, POST, PUT, DELETE) 서버가 수행해야 할 동작 지정
* 요청대상: 절대경로 + 쿼리 스트링 ( 다른 경로 지정 방법도 있긴 하다.)
* HTTP Vertion

&#x20;status line (응답 메세지)

* status-line = HTTP Version + 상태 코드 + 이유 문구(사람이 이해할 수 있는 짧은 상태코드 설명 )
* &#x20;상태코드: 200 성공, 400 클라이언트 요청 오류, 500  서버 내부 오류

#### 2. 헤더 => 필드 네임: 필드 벨류

* 필드 네임은 대소문자 구분 없지만 값은 대소문자 구분을 한다.
* HTTP 전송에 필요한 모든 메타데이터 정보 ex. 메세지 바디의 크기, 형식, 압축 여부, 인증 여부, 요청 클라이언트 정보, 서버 어플리케이션 정보, 캐시 관리 정보 등
* Host: www.google.com
* Content-Type: text/html;charset=UTF-8

#### 3. 바디

* 실제 전송할 바이트로 표현할 수 있는 모든 데이터 (html, 이미지, 영상, json )
